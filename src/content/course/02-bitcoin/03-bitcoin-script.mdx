---
title: "Bitcoin Script"
description: "Стековый язык программирования транзакций Bitcoin"
order: 3
difficulty: "intermediate"
estimatedTime: 35
topics: ["Bitcoin Script", "Stack Machine", "P2PKH", "P2SH"]
---

import { ScriptStackDiagram, P2PKHDiagram, ScriptTypesDiagram } from '../../../components/diagrams/module2';

# Bitcoin Script

## Что такое Bitcoin Script?

**Bitcoin Script** — это стековый, не Тьюринг-полный язык программирования, определяющий условия траты BTC.

Каждая транзакция содержит:
- **scriptPubKey** (locking script) — условие блокировки
- **scriptSig** (unlocking script) — доказательство выполнения условия

<ScriptStackDiagram client:load />

## Стековая машина

```python
class ScriptInterpreter:
    """Интерпретатор Bitcoin Script"""

    def __init__(self):
        self.stack = []
        self.alt_stack = []

    def push(self, data):
        self.stack.append(data)

    def pop(self):
        if not self.stack:
            raise Exception("Stack underflow")
        return self.stack.pop()

    def peek(self):
        return self.stack[-1] if self.stack else None

    def execute(self, script: list) -> bool:
        """
        Выполнить скрипт.
        Возвращает True если на вершине стека ненулевое значение.
        """
        for op in script:
            if isinstance(op, bytes):
                # Данные — кладём на стек
                self.push(op)
            elif isinstance(op, str):
                # Опкод — выполняем операцию
                self._execute_op(op)
            else:
                raise Exception(f"Unknown instruction: {op}")

        # Скрипт успешен, если стек непуст и верхний элемент = True
        return len(self.stack) > 0 and bool(self.stack[-1])

    def _execute_op(self, op: str):
        if op == "OP_DUP":
            self.push(self.peek())

        elif op == "OP_HASH160":
            import hashlib
            data = self.pop()
            sha = hashlib.sha256(data).digest()
            ripemd = hashlib.new('ripemd160', sha).digest()
            self.push(ripemd)

        elif op == "OP_EQUALVERIFY":
            a = self.pop()
            b = self.pop()
            if a != b:
                raise Exception("OP_EQUALVERIFY failed")

        elif op == "OP_CHECKSIG":
            pubkey = self.pop()
            signature = self.pop()
            # Упрощённо — в реальности проверяем ECDSA
            is_valid = self._verify_signature(signature, pubkey)
            self.push(b'\x01' if is_valid else b'\x00')

        elif op == "OP_EQUAL":
            a = self.pop()
            b = self.pop()
            self.push(b'\x01' if a == b else b'\x00')

        elif op == "OP_VERIFY":
            if not self.pop():
                raise Exception("OP_VERIFY failed")

        elif op == "OP_RETURN":
            raise Exception("OP_RETURN: script terminated")

        elif op == "OP_ADD":
            a = int.from_bytes(self.pop(), 'little', signed=True)
            b = int.from_bytes(self.pop(), 'little', signed=True)
            result = a + b
            self.push(result.to_bytes(4, 'little', signed=True))

        elif op == "OP_CHECKMULTISIG":
            # Multisig verification
            n = int.from_bytes(self.pop(), 'little')
            pubkeys = [self.pop() for _ in range(n)]
            m = int.from_bytes(self.pop(), 'little')
            sigs = [self.pop() for _ in range(m)]
            self.pop()  # Off-by-one bug (historical)
            # Verify m-of-n
            self.push(b'\x01')  # Simplified

    def _verify_signature(self, sig, pubkey) -> bool:
        """Упрощённая проверка подписи"""
        return True  # В реальности: ECDSA verify
```

## P2PKH: Pay to Public Key Hash

Самый распространённый тип транзакции.

<P2PKHDiagram client:load />

```python
# Locking Script (scriptPubKey):
# OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG

# Unlocking Script (scriptSig):
# <signature> <publicKey>

# Полный скрипт (scriptSig + scriptPubKey):
def p2pkh_example():
    interp = ScriptInterpreter()

    # Данные Alice
    alice_pubkey = b'\x04' + b'\xaa' * 64  # Публичный ключ
    alice_signature = b'\x30' + b'\xbb' * 70  # Подпись

    # PubKeyHash
    import hashlib
    sha = hashlib.sha256(alice_pubkey).digest()
    pubkey_hash = hashlib.new('ripemd160', sha).digest()

    # Выполняем scriptSig (unlocking)
    script = [
        alice_signature,      # <signature>
        alice_pubkey,          # <publicKey>

        # scriptPubKey (locking)
        "OP_DUP",             # Дублируем publicKey
        "OP_HASH160",         # HASH160(publicKey)
        pubkey_hash,          # <pubKeyHash>
        "OP_EQUALVERIFY",     # Сравниваем хеши
        "OP_CHECKSIG",        # Проверяем подпись
    ]

    result = interp.execute(script)
    print(f"P2PKH valid: {result}")

p2pkh_example()
```

### Пошаговое выполнение P2PKH

```python
# Стек после каждой операции:
#
# 1. <sig>                    → [sig]
# 2. <pubkey>                 → [sig, pubkey]
# 3. OP_DUP                   → [sig, pubkey, pubkey]
# 4. OP_HASH160                → [sig, pubkey, hash160(pubkey)]
# 5. <pubKeyHash>              → [sig, pubkey, hash160(pubkey), pubKeyHash]
# 6. OP_EQUALVERIFY            → [sig, pubkey]  (hash160 == pubKeyHash)
# 7. OP_CHECKSIG               → [true]
```

## Типы стандартных скриптов

<ScriptTypesDiagram client:load />

### P2PK (Pay to Public Key) — устаревший

```python
# scriptPubKey: <pubkey> OP_CHECKSIG
# scriptSig: <signature>
# Проблема: публичный ключ виден до траты
```

### P2SH (Pay to Script Hash)

```python
# Позволяет отправлять на хеш скрипта (более гибко)
# scriptPubKey: OP_HASH160 <scriptHash> OP_EQUAL
# scriptSig: <data...> <redeemScript>

# Пример: 2-of-3 Multisig
redeem_script = [
    "OP_2",                    # m = 2
    alice_pubkey,              # Публичный ключ 1
    bob_pubkey,                # Публичный ключ 2
    carol_pubkey,              # Публичный ключ 3
    "OP_3",                    # n = 3
    "OP_CHECKMULTISIG"
]
```

### P2WPKH (SegWit v0) — рекомендуемый

```python
# scriptPubKey: OP_0 <20-byte-pubkey-hash>
# witness: <signature> <publicKey>

# Преимущества:
# - Меньше размер транзакции (скидка на witness data)
# - Исправлена проблема malleability
# - Адреса начинаются с bc1q...
```

### P2TR (Taproot / SegWit v1) — современный

```python
# scriptPubKey: OP_1 <32-byte-tweaked-pubkey>
# witness: <signature> (key path)
#   или:  <script> <control-block> (script path)

# Преимущества:
# - Schnorr подписи
# - MAST (Merkelized Abstract Syntax Trees)
# - Улучшенная приватность
# - Адреса начинаются с bc1p...
```

## Практика: Создание скриптов

```python
# Подключение к Bitcoin Core regtest
rpc = BitcoinRPC()

# P2PKH транзакция
address_legacy = rpc.call("getnewaddress", ["", "legacy"])
print(f"P2PKH: {address_legacy}")  # Начинается с m или n (regtest)

# P2SH-P2WPKH (nested SegWit)
address_nested = rpc.call("getnewaddress", ["", "p2sh-segwit"])
print(f"P2SH-P2WPKH: {address_nested}")  # Начинается с 2

# P2WPKH (native SegWit)
address_segwit = rpc.call("getnewaddress", ["", "bech32"])
print(f"P2WPKH: {address_segwit}")  # Начинается с bcrt1q

# P2TR (Taproot)
address_taproot = rpc.call("getnewaddress", ["", "bech32m"])
print(f"P2TR: {address_taproot}")  # Начинается с bcrt1p

# Декодирование скрипта
script_hex = "76a914" + "0" * 40 + "88ac"
decoded = rpc.call("decodescript", [script_hex])
print(f"Type: {decoded['type']}")
print(f"Address: {decoded.get('address', 'N/A')}")
```

## Таймлоки

```python
# OP_CHECKLOCKTIMEVERIFY (CLTV) — абсолютный таймлок
# "Можно потратить только после блока #800000"
cltv_script = [
    b'\x00\x35\x0c\x00',   # 800000 (little-endian)
    "OP_CHECKLOCKTIMEVERIFY",
    "OP_DROP",
    alice_pubkey,
    "OP_CHECKSIG"
]

# OP_CHECKSEQUENCEVERIFY (CSV) — относительный таймлок
# "Можно потратить через 144 блока (~1 день) после создания"
csv_script = [
    b'\x90\x00',            # 144 (little-endian)
    "OP_CHECKSEQUENCEVERIFY",
    "OP_DROP",
    alice_pubkey,
    "OP_CHECKSIG"
]
```

## Ключевые выводы

1. **Bitcoin Script** — стековый, не Тьюринг-полный язык
2. **scriptPubKey** блокирует UTXO, **scriptSig** разблокирует
3. **P2PKH** — классический тип (адреса начинаются с 1)
4. **P2WPKH** — SegWit (bc1q), **P2TR** — Taproot (bc1p)
5. **Таймлоки** позволяют создавать условия на время траты

## Что дальше?

В следующем уроке мы изучим **структуру блоков Bitcoin** и как транзакции организуются внутри блока.
