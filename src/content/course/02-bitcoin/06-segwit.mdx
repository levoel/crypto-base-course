---
title: "Segregated Witness (SegWit)"
description: "SegWit — решение проблемы malleability и увеличение пропускной способности Bitcoin"
order: 6
difficulty: "intermediate"
estimatedTime: 35
topics: ["SegWit", "Transaction Malleability", "Weight Units", "Witness"]
---

import { SegWitStructureDiagram, MalleabilityDiagram, WeightCalculationDiagram } from '../../../components/diagrams/module2';

# Segregated Witness (SegWit)

## Проблема Transaction Malleability

<MalleabilityDiagram client:load />

**Transaction Malleability** — возможность изменить txid транзакции, не меняя её суть:

```python
# Проблема: подпись (scriptSig) является частью данных для txid
# Изменение формата подписи (DER encoding) меняет txid,
# при этом подпись остаётся валидной

import hashlib

def legacy_txid(version, inputs, outputs, locktime):
    """Legacy: txid включает scriptSig (подписи)"""
    raw = version + inputs + outputs + locktime
    return hashlib.sha256(hashlib.sha256(raw).digest()).digest()

# Атакующий может изменить scriptSig (формат подписи),
# что изменит txid, но транзакция останется валидной!

# Это ломает:
# 1. Цепочки неподтверждённых транзакций
# 2. Payment channels (Lightning Network)
# 3. Любую логику, зависящую от txid
```

## Решение: SegWit (BIP-141)

<SegWitStructureDiagram client:load />

**Ключевая идея:** вынести подписи (witness data) из основной транзакции:

```python
class SegWitTransaction:
    """Структура SegWit транзакции"""

    def __init__(self):
        self.version = 2
        self.marker = 0x00      # SegWit маркер
        self.flag = 0x01        # SegWit флаг
        self.inputs = []
        self.outputs = []
        self.witness = []       # Данные подписей — ОТДЕЛЬНО
        self.locktime = 0

    def txid(self) -> bytes:
        """
        txid НЕ включает witness данные!
        Это решает проблему malleability.
        """
        # Сериализация БЕЗ marker, flag и witness
        data = b''
        data += self.version.to_bytes(4, 'little')
        data += self._serialize_inputs()
        data += self._serialize_outputs()
        data += self.locktime.to_bytes(4, 'little')

        import hashlib
        return hashlib.sha256(hashlib.sha256(data).digest()).digest()

    def wtxid(self) -> bytes:
        """
        wtxid ВКЛЮЧАЕТ witness данные.
        Используется для witness merkle tree.
        """
        data = b''
        data += self.version.to_bytes(4, 'little')
        data += bytes([self.marker, self.flag])
        data += self._serialize_inputs()
        data += self._serialize_outputs()
        data += self._serialize_witness()
        data += self.locktime.to_bytes(4, 'little')

        import hashlib
        return hashlib.sha256(hashlib.sha256(data).digest()).digest()

    def _serialize_inputs(self) -> bytes:
        result = len(self.inputs).to_bytes(1, 'little')
        for inp in self.inputs:
            result += bytes.fromhex(inp['txid'])[::-1]
            result += inp['vout'].to_bytes(4, 'little')
            # SegWit: scriptSig пустой для native SegWit
            result += b'\x00'
            result += inp.get('sequence', 0xFFFFFFFF).to_bytes(4, 'little')
        return result

    def _serialize_outputs(self) -> bytes:
        result = len(self.outputs).to_bytes(1, 'little')
        for out in self.outputs:
            result += out['value'].to_bytes(8, 'little')
            script = bytes.fromhex(out['scriptPubKey'])
            result += len(script).to_bytes(1, 'little')
            result += script
        return result

    def _serialize_witness(self) -> bytes:
        result = b''
        for witness_stack in self.witness:
            result += len(witness_stack).to_bytes(1, 'little')
            for item in witness_stack:
                data = bytes.fromhex(item)
                result += len(data).to_bytes(1, 'little')
                result += data
        return result
```

## Weight Units и Virtual Bytes

<WeightCalculationDiagram client:load />

SegWit ввёл новую систему измерения размера транзакций:

```python
class TransactionWeight:
    """Расчёт weight и vsize транзакции"""

    @staticmethod
    def calculate(tx_bytes: bytes, witness_bytes: bytes) -> dict:
        """
        Weight = base_size × 4 + witness_size × 1

        - base_size: всё кроме witness (по старым правилам)
        - witness_size: только witness данные
        - vsize = weight / 4 (округление вверх)

        Максимум блока: 4,000,000 weight units (= 4 MW)
        """
        base_size = len(tx_bytes)
        witness_size = len(witness_bytes)

        weight = base_size * 4 + witness_size * 1
        vsize = (weight + 3) // 4  # ceiling division

        return {
            "base_size": base_size,
            "witness_size": witness_size,
            "total_size": base_size + witness_size,
            "weight": weight,
            "vsize": vsize,
            "witness_discount": f"{witness_size / (base_size + witness_size) * 100:.1f}%"
        }

# Пример: типичная P2WPKH транзакция (1 вход, 2 выхода)
# base: ~113 байт, witness: ~107 байт
result = TransactionWeight.calculate(
    tx_bytes=bytes(113),
    witness_bytes=bytes(107)
)

print(f"Base size: {result['base_size']} bytes")
print(f"Witness size: {result['witness_size']} bytes")
print(f"Total size: {result['total_size']} bytes")
print(f"Weight: {result['weight']} WU")
print(f"Virtual size: {result['vsize']} vbytes")
print(f"Witness discount: {result['witness_discount']}")

# Сравнение: legacy vs SegWit
print("\n--- Сравнение ---")
legacy_size = 226  # типичная legacy P2PKH
segwit_vsize = result['vsize']
print(f"Legacy P2PKH: {legacy_size} vbytes")
print(f"SegWit P2WPKH: {segwit_vsize} vbytes")
print(f"Экономия: {(1 - segwit_vsize/legacy_size)*100:.0f}%")
```

## Типы SegWit адресов

```python
import hashlib
import struct

def hash160(data: bytes) -> bytes:
    return hashlib.new('ripemd160', hashlib.sha256(data).digest()).digest()

def sha256(data: bytes) -> bytes:
    return hashlib.sha256(data).digest()

class SegWitAddress:
    """Генерация SegWit адресов"""

    # Bech32 charset
    CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l"

    @staticmethod
    def p2wpkh_script(pubkey_hash: bytes) -> bytes:
        """
        P2WPKH (Pay to Witness Public Key Hash)
        scriptPubKey: OP_0 <20-byte-hash>
        Адрес: bc1q...
        """
        return b'\x00\x14' + pubkey_hash

    @staticmethod
    def p2wsh_script(script_hash: bytes) -> bytes:
        """
        P2WSH (Pay to Witness Script Hash)
        scriptPubKey: OP_0 <32-byte-hash>
        Адрес: bc1q... (длиннее чем P2WPKH)
        """
        return b'\x00\x20' + script_hash

    @staticmethod
    def p2sh_p2wpkh_script(pubkey_hash: bytes) -> bytes:
        """
        P2SH-P2WPKH (wrapped SegWit)
        Совместим со старыми кошельками
        Адрес: 3... (выглядит как обычный P2SH)
        """
        witness_script = b'\x00\x14' + pubkey_hash
        script_hash = hash160(witness_script)
        return b'\xa9\x14' + script_hash + b'\x87'  # OP_HASH160 <hash> OP_EQUAL

    @staticmethod
    def bech32_encode(hrp: str, witness_version: int, witness_program: bytes) -> str:
        """Кодирование Bech32 адреса (BIP-173)"""
        data = [witness_version] + SegWitAddress._convertbits(
            list(witness_program), 8, 5
        )
        checksum = SegWitAddress._bech32_checksum(hrp, data)
        return hrp + '1' + ''.join(
            SegWitAddress.CHARSET[d] for d in data + checksum
        )

    @staticmethod
    def _convertbits(data, frombits, tobits, pad=True):
        acc = 0
        bits = 0
        ret = []
        maxv = (1 << tobits) - 1
        for value in data:
            acc = (acc << frombits) | value
            bits += frombits
            while bits >= tobits:
                bits -= tobits
                ret.append((acc >> bits) & maxv)
        if pad and bits:
            ret.append((acc << (tobits - bits)) & maxv)
        return ret

    @staticmethod
    def _bech32_polymod(values):
        GEN = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3]
        chk = 1
        for v in values:
            b = chk >> 25
            chk = ((chk & 0x1ffffff) << 5) ^ v
            for i in range(5):
                chk ^= GEN[i] if ((b >> i) & 1) else 0
        return chk

    @staticmethod
    def _bech32_checksum(hrp, data):
        values = [ord(c) >> 5 for c in hrp] + [0] + \
                 [ord(c) & 31 for c in hrp] + data
        polymod = SegWitAddress._bech32_polymod(values + [0]*6) ^ 1
        return [(polymod >> 5 * (5 - i)) & 31 for i in range(6)]


# Пример
pubkey_hash = bytes(20)  # заглушка
print("P2WPKH script:", SegWitAddress.p2wpkh_script(pubkey_hash).hex())
print("P2WSH script:", SegWitAddress.p2wsh_script(bytes(32)).hex())
```

## Witness Program версии

```python
witness_versions = {
    0: {
        "name": "SegWit v0",
        "bip": "BIP-141",
        "types": ["P2WPKH (20 bytes)", "P2WSH (32 bytes)"],
        "address_prefix": "bc1q",
        "encoding": "Bech32",
        "activated": "August 2017",
    },
    1: {
        "name": "SegWit v1 (Taproot)",
        "bip": "BIP-341",
        "types": ["P2TR (32 bytes)"],
        "address_prefix": "bc1p",
        "encoding": "Bech32m",
        "activated": "November 2021",
    },
    # Версии 2-16 зарезервированы для будущих обновлений
}

for version, info in witness_versions.items():
    print(f"\n=== Witness v{version}: {info['name']} ===")
    print(f"  BIP: {info['bip']}")
    print(f"  Types: {', '.join(info['types'])}")
    print(f"  Prefix: {info['address_prefix']}")
    print(f"  Encoding: {info['encoding']}")
    print(f"  Activated: {info['activated']}")
```

## BIP-143: Новый алгоритм подписи

```python
import hashlib
import struct

def double_sha256(data: bytes) -> bytes:
    return hashlib.sha256(hashlib.sha256(data).digest()).digest()

class SegWitSighash:
    """BIP-143: новый алгоритм вычисления sighash для SegWit"""

    @staticmethod
    def compute(tx, input_index: int, script_code: bytes,
                value: int, hash_type: int = 1) -> bytes:
        """
        Преимущества BIP-143 над legacy sighash:
        1. O(1) вместо O(n²) — не нужно сериализовать всю tx для каждого входа
        2. Значение входа подписывается (защита от fee attack)
        3. Детерминированное вычисление
        """
        # Предварительно хешированные компоненты (кешируются!)
        hash_prevouts = double_sha256(b''.join(
            bytes.fromhex(inp['txid'])[::-1] + inp['vout'].to_bytes(4, 'little')
            for inp in tx['inputs']
        ))

        hash_sequence = double_sha256(b''.join(
            inp.get('sequence', 0xFFFFFFFF).to_bytes(4, 'little')
            for inp in tx['inputs']
        ))

        hash_outputs = double_sha256(b''.join(
            out['value'].to_bytes(8, 'little') +
            len(bytes.fromhex(out['script'])).to_bytes(1, 'little') +
            bytes.fromhex(out['script'])
            for out in tx['outputs']
        ))

        # Собираем preimage
        preimage = b''
        preimage += tx['version'].to_bytes(4, 'little')
        preimage += hash_prevouts
        preimage += hash_sequence

        # Текущий вход
        inp = tx['inputs'][input_index]
        preimage += bytes.fromhex(inp['txid'])[::-1]
        preimage += inp['vout'].to_bytes(4, 'little')
        preimage += len(script_code).to_bytes(1, 'little') + script_code
        preimage += value.to_bytes(8, 'little')  # Значение ПОДПИСЫВАЕТСЯ!
        preimage += inp.get('sequence', 0xFFFFFFFF).to_bytes(4, 'little')

        preimage += hash_outputs
        preimage += tx['locktime'].to_bytes(4, 'little')
        preimage += hash_type.to_bytes(4, 'little')

        return double_sha256(preimage)

# Это решает quadratic sighash problem:
# Legacy: O(n²) — для каждого из n входов сериализуем все n входов
# SegWit: O(n) — hash_prevouts и hash_sequence вычисляются один раз
```

## Backward Compatibility

```python
# SegWit достиг backward compatibility через soft fork:
# Старые ноды видят witness data как "anyone-can-spend"

compatibility = {
    "soft_fork": {
        "description": "Старые ноды не отклоняют SegWit транзакции",
        "mechanism": "witness data не включается в legacy сериализацию",
        "activation": "BIP-9 (bit 1), locked in block 477,120",
    },
    "wrapped_segwit": {
        "description": "P2SH-P2WPKH для совместимости со старыми кошельками",
        "trade_off": "Немного больше размер, чем native SegWit",
        "address_format": "3... (стандартный P2SH формат)",
    },
    "native_segwit": {
        "description": "Bech32 адреса (bc1q...) — максимальная экономия",
        "requirement": "Отправитель должен поддерживать Bech32",
        "adoption": "~85% транзакций (2024)",
    }
}

for key, info in compatibility.items():
    print(f"\n{key}:")
    for k, v in info.items():
        print(f"  {k}: {v}")
```

## Ключевые выводы

1. **SegWit** выносит подписи (witness) из txid — решает malleability
2. **Weight units**: base × 4 + witness × 1, максимум 4 MW на блок
3. **Экономия ~40%** на комиссиях для P2WPKH vs P2PKH
4. **BIP-143** — O(n) sighash вместо O(n²), подписывает значение входа
5. **Bech32** адреса (bc1q...) — native SegWit формат

## Что дальше?

В следующем уроке мы изучим **Taproot** — обновление, построенное на SegWit v1, которое принесло Schnorr подписи и MAST в Bitcoin.
