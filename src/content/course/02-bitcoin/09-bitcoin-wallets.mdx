---
title: "Bitcoin кошельки и HD-деривация"
description: "Иерархические детерминированные кошельки — BIP-32, BIP-39, BIP-44"
order: 9
difficulty: "intermediate"
estimatedTime: 35
topics: ["HD Wallets", "BIP-32", "BIP-39", "BIP-44", "Seed Phrase", "Key Derivation"]
---

import { HDWalletDiagram, DerivationPathDiagram, SeedPhraseDiagram, WalletTypeDiagram } from '../../../components/diagrams/module2';

# Bitcoin кошельки и HD-деривация

## Эволюция кошельков

<WalletTypeDiagram client:load />

```python
wallet_evolution = [
    {
        "type": "JBOK (Just a Bunch of Keys)",
        "era": "2009–2012",
        "method": "Случайная генерация ключей",
        "backup": "Каждый ключ отдельно",
        "problem": "100+ ключей, backup после каждого нового адреса",
    },
    {
        "type": "Deterministic (Type-1)",
        "era": "2012–2013",
        "method": "Все ключи из одного seed",
        "backup": "Один seed",
        "problem": "Плоская структура, нет аккаунтов",
    },
    {
        "type": "HD Wallet (BIP-32)",
        "era": "2013+",
        "method": "Иерархическая деривация из master key",
        "backup": "12/24 слова (BIP-39)",
        "problem": "Решено — стандарт индустрии",
    },
]

for w in wallet_evolution:
    print(f"\n=== {w['type']} ({w['era']}) ===")
    for k, v in w.items():
        if k not in ('type', 'era'):
            print(f"  {k}: {v}")
```

## BIP-39: Мнемонические фразы

<SeedPhraseDiagram client:load />

```python
import hashlib
import os

class BIP39:
    """
    BIP-39: мнемоническая фраза → seed

    1. Генерируем энтропию (128-256 бит)
    2. Добавляем checksum (ENT/32 бит)
    3. Разбиваем на группы по 11 бит
    4. Каждая группа — индекс слова (0-2047)
    """

    # Первые/последние слова из BIP-39 English wordlist
    WORDLIST_SAMPLE = [
        "abandon", "ability", "able", "about", "above",
        "absent", "absorb", "abstract", "absurd", "abuse",
        "access", "accident",
        # ... 2048 слов всего
    ]

    @staticmethod
    def entropy_to_mnemonic(entropy: bytes) -> list:
        """
        Entropy → Mnemonic Words

        128 бит → 12 слов
        160 бит → 15 слов
        192 бит → 18 слов
        224 бит → 21 слово
        256 бит → 24 слова
        """
        ent_bits = len(entropy) * 8
        assert ent_bits in (128, 160, 192, 224, 256)

        # Checksum: первые ENT/32 бит SHA-256
        checksum_bits = ent_bits // 32
        h = hashlib.sha256(entropy).digest()
        checksum = bin(h[0])[2:].zfill(8)[:checksum_bits]

        # Конкатенация entropy + checksum
        bits = bin(int.from_bytes(entropy, 'big'))[2:].zfill(ent_bits) + checksum

        # Разбиваем на группы по 11 бит
        word_count = (ent_bits + checksum_bits) // 11
        indices = []
        for i in range(word_count):
            index = int(bits[i*11:(i+1)*11], 2)
            indices.append(index)

        return {
            "entropy_bits": ent_bits,
            "checksum_bits": checksum_bits,
            "total_bits": ent_bits + checksum_bits,
            "word_count": word_count,
            "indices": indices,
            "security": f"2^{ent_bits} возможных комбинаций",
        }

    @staticmethod
    def mnemonic_to_seed(mnemonic: str, passphrase: str = "") -> bytes:
        """
        Mnemonic → Seed (512 бит)

        PBKDF2-HMAC-SHA512:
        - password = mnemonic (UTF-8 NFKD)
        - salt = "mnemonic" + passphrase
        - iterations = 2048
        - dkLen = 64
        """
        import hmac

        password = mnemonic.encode('utf-8')
        salt = ("mnemonic" + passphrase).encode('utf-8')

        # PBKDF2 (упрощённая реализация)
        seed = hashlib.pbkdf2_hmac(
            'sha512',
            password,
            salt,
            iterations=2048,
            dklen=64
        )
        return seed


# Пример
entropy = os.urandom(16)  # 128 бит → 12 слов
result = BIP39.entropy_to_mnemonic(entropy)
print("=== BIP-39 ===")
for k, v in result.items():
    print(f"  {k}: {v}")

# Seed generation
mnemonic = "abandon " * 11 + "about"  # тестовая фраза
seed = BIP39.mnemonic_to_seed(mnemonic)
print(f"\nSeed (hex): {seed.hex()[:64]}...")
print(f"Seed length: {len(seed)} bytes ({len(seed)*8} bits)")

# Passphrase добавляет дополнительный уровень защиты
seed_with_pass = BIP39.mnemonic_to_seed(mnemonic, "my secret passphrase")
print(f"\nС passphrase: {seed_with_pass.hex()[:64]}...")
print("Разные seed → разные кошельки! (Plausible deniability)")
```

## BIP-32: Hierarchical Deterministic Wallets

<HDWalletDiagram client:load />

```python
import hashlib
import hmac
import struct

class BIP32:
    """
    BIP-32: HD Wallet — иерархическая деривация ключей.

    Master Key → Child Keys → Grandchild Keys...

    Два типа деривации:
    - Normal (public): можно вывести child pubkey из parent pubkey
    - Hardened (private): нужен parent private key
    """

    SECP256K1_ORDER = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141

    @staticmethod
    def master_key_from_seed(seed: bytes) -> dict:
        """
        Seed → Master Key

        HMAC-SHA512(key="Bitcoin seed", data=seed)
        Left 32 bytes = master private key
        Right 32 bytes = master chain code
        """
        I = hmac.new(b"Bitcoin seed", seed, hashlib.sha512).digest()

        master_key = I[:32]
        chain_code = I[32:]

        key_int = int.from_bytes(master_key, 'big')
        assert 0 < key_int < BIP32.SECP256K1_ORDER

        return {
            "private_key": master_key,
            "chain_code": chain_code,
            "depth": 0,
            "index": 0,
            "parent_fingerprint": b'\x00\x00\x00\x00',
        }

    @staticmethod
    def derive_child(parent_key: bytes, parent_chain: bytes,
                     index: int, hardened: bool = False) -> dict:
        """
        Child Key Derivation:

        Normal (index < 2^31):
          HMAC-SHA512(chain_code, pubkey || index)
          → child может быть выведен из parent pubkey

        Hardened (index >= 2^31):
          HMAC-SHA512(chain_code, 0x00 || privkey || index)
          → нужен parent private key
        """
        if hardened:
            index += 0x80000000  # Set hardened bit
            data = b'\x00' + parent_key + struct.pack('>I', index)
        else:
            # Нужен pubkey (упрощаем)
            pubkey = parent_key  # placeholder
            data = pubkey + struct.pack('>I', index)

        I = hmac.new(parent_chain, data, hashlib.sha512).digest()

        child_key_add = int.from_bytes(I[:32], 'big')
        parent_key_int = int.from_bytes(parent_key, 'big')

        child_key_int = (child_key_add + parent_key_int) % BIP32.SECP256K1_ORDER
        child_key = child_key_int.to_bytes(32, 'big')
        child_chain = I[32:]

        return {
            "private_key": child_key,
            "chain_code": child_chain,
            "index": index,
            "hardened": hardened,
        }

    @staticmethod
    def extended_key_format() -> dict:
        """
        Extended Key (xpub/xprv): 78 bytes

        Позволяет экспортировать ветку дерева
        """
        return {
            "version": "4 bytes (xpub: 0x0488B21E, xprv: 0x0488ADE4)",
            "depth": "1 byte (0x00 for master)",
            "fingerprint": "4 bytes (parent key fingerprint)",
            "child_number": "4 bytes (index)",
            "chain_code": "32 bytes",
            "key": "33 bytes (pubkey or 0x00 + privkey)",
            "total": "78 bytes → Base58Check encoding",
            "example_xpub": "xpub661MyMwAqRbc...",
            "example_xprv": "xprv9s21ZrQH143K...",
        }


# Пример
seed = bytes.fromhex("000102030405060708090a0b0c0d0e0f")
master = BIP32.master_key_from_seed(seed)
print("=== Master Key ===")
print(f"  Private key: {master['private_key'].hex()}")
print(f"  Chain code: {master['chain_code'].hex()}")

# Деривация
child = BIP32.derive_child(
    master['private_key'],
    master['chain_code'],
    index=0,
    hardened=True
)
print(f"\n=== Child m/0' ===")
print(f"  Private key: {child['private_key'].hex()}")
print(f"  Hardened: {child['hardened']}")
```

## BIP-44: Derivation Paths

<DerivationPathDiagram client:load />

```python
class BIP44:
    """
    BIP-44: Multi-Account Hierarchy

    Путь: m / purpose' / coin_type' / account' / change / address_index

    Все уровни до account — hardened (')
    change и address_index — normal (для xpub деривации)
    """

    COIN_TYPES = {
        0: "Bitcoin",
        1: "Bitcoin Testnet",
        2: "Litecoin",
        60: "Ethereum",
        501: "Solana",
        784: "Sui",
    }

    PURPOSES = {
        44: "BIP-44 (Legacy P2PKH)",
        49: "BIP-49 (Nested SegWit P2SH-P2WPKH)",
        84: "BIP-84 (Native SegWit P2WPKH)",
        86: "BIP-86 (Taproot P2TR)",
    }

    @staticmethod
    def parse_path(path: str) -> dict:
        """Разбор derivation path"""
        parts = path.split('/')
        assert parts[0] == 'm'

        levels = []
        for part in parts[1:]:
            hardened = part.endswith("'") or part.endswith("h")
            index = int(part.rstrip("'h"))
            levels.append({"index": index, "hardened": hardened})

        return {
            "path": path,
            "depth": len(levels),
            "purpose": levels[0]["index"] if levels else None,
            "coin_type": levels[1]["index"] if len(levels) > 1 else None,
            "account": levels[2]["index"] if len(levels) > 2 else None,
            "change": levels[3]["index"] if len(levels) > 3 else None,
            "address_index": levels[4]["index"] if len(levels) > 4 else None,
        }

    @staticmethod
    def common_paths() -> list:
        """Стандартные derivation paths"""
        return [
            {
                "path": "m/44'/0'/0'/0/0",
                "type": "Bitcoin Legacy (P2PKH)",
                "address_prefix": "1...",
                "bip": "BIP-44",
            },
            {
                "path": "m/49'/0'/0'/0/0",
                "type": "Bitcoin Wrapped SegWit (P2SH-P2WPKH)",
                "address_prefix": "3...",
                "bip": "BIP-49",
            },
            {
                "path": "m/84'/0'/0'/0/0",
                "type": "Bitcoin Native SegWit (P2WPKH)",
                "address_prefix": "bc1q...",
                "bip": "BIP-84",
            },
            {
                "path": "m/86'/0'/0'/0/0",
                "type": "Bitcoin Taproot (P2TR)",
                "address_prefix": "bc1p...",
                "bip": "BIP-86",
            },
            {
                "path": "m/44'/60'/0'/0/0",
                "type": "Ethereum",
                "address_prefix": "0x...",
                "bip": "BIP-44",
            },
            {
                "path": "m/44'/501'/0'/0'",
                "type": "Solana",
                "address_prefix": "Base58...",
                "bip": "BIP-44 (modified)",
            },
        ]


# Пример
print("=== Стандартные Derivation Paths ===\n")
for p in BIP44.common_paths():
    print(f"{p['path']}")
    print(f"  {p['type']} ({p['address_prefix']})\n")

# Разбор пути
parsed = BIP44.parse_path("m/84'/0'/0'/0/5")
print(f"=== Разбор: {parsed['path']} ===")
print(f"  Purpose: {parsed['purpose']} ({BIP44.PURPOSES.get(parsed['purpose'], '?')})")
print(f"  Coin: {parsed['coin_type']} ({BIP44.COIN_TYPES.get(parsed['coin_type'], '?')})")
print(f"  Account: {parsed['account']}")
print(f"  Change: {parsed['change']} ({'internal' if parsed['change'] else 'external'})")
print(f"  Address: {parsed['address_index']}")
```

## Gap Limit и Address Discovery

```python
class AddressDiscovery:
    """
    Алгоритм обнаружения адресов при восстановлении кошелька.

    Gap Limit = 20 (по умолчанию):
    Сканируем адреса, пока не найдём 20 подряд неиспользованных.
    """

    def __init__(self, gap_limit: int = 20):
        self.gap_limit = gap_limit

    def scan(self, derive_address, check_used) -> dict:
        """
        Сканирование цепочки адресов:
        1. Начинаем с index = 0
        2. Проверяем адрес на активность (транзакции)
        3. Если адрес использован — сбрасываем gap counter
        4. Если gap counter = gap_limit — останавливаемся
        """
        addresses = []
        gap = 0
        index = 0
        last_used = -1

        while gap < self.gap_limit:
            address = derive_address(index)
            used = check_used(address)

            if used:
                gap = 0
                last_used = index
            else:
                gap += 1

            addresses.append({
                "index": index,
                "address": address,
                "used": used,
            })
            index += 1

        return {
            "total_scanned": len(addresses),
            "used_count": sum(1 for a in addresses if a["used"]),
            "last_used_index": last_used,
            "gap_limit_reached": True,
        }

    @staticmethod
    def full_wallet_scan():
        """
        Полное сканирование:
        Для каждого purpose (44, 49, 84, 86):
          Для каждого account (0, 1, 2, ...):
            Сканируем external chain (change=0)
            Сканируем internal chain (change=1)
        """
        return {
            "purposes": [44, 49, 84, 86],
            "accounts": "Сканируем пока не найдём пустой account",
            "chains": ["external (change=0)", "internal (change=1)"],
            "per_chain": "Gap limit = 20 адресов",
            "total_calls": "~4 × accounts × 2 × 20 = минимум ~160 запросов",
        }

scan_info = AddressDiscovery.full_wallet_scan()
print("=== Wallet Discovery ===")
for k, v in scan_info.items():
    print(f"  {k}: {v}")
```

## Безопасность кошельков

```python
security_practices = {
    "seed_storage": {
        "DO": [
            "Записать на бумаге/металле",
            "Хранить в нескольких местах",
            "Использовать passphrase (25-е слово)",
            "Shamir's Secret Sharing (SLIP-39)",
        ],
        "DONT": [
            "Хранить в цифровом виде (файл, фото, email)",
            "Хранить в облаке",
            "Использовать brain wallet",
            "Делиться seed с кем-либо",
        ],
    },
    "xpub_risks": {
        "what_xpub_reveals": [
            "Все прошлые и будущие адреса",
            "Все балансы",
            "Все входящие/исходящие транзакции",
        ],
        "what_xpub_cannot": [
            "Потратить средства (нужен xprv)",
            "Подписать транзакции",
        ],
        "risk": "Утечка xpub = полная потеря приватности",
    },
    "address_reuse": {
        "problem": "Связывает транзакции одного пользователя",
        "solution": "HD wallet генерирует новый адрес для каждого платежа",
        "change_address": "Сдача отправляется на internal chain (change=1)",
    },
}

for category, info in security_practices.items():
    print(f"\n=== {category} ===")
    for k, v in info.items():
        if isinstance(v, list):
            print(f"  {k}:")
            for item in v:
                print(f"    - {item}")
        else:
            print(f"  {k}: {v}")
```

## Ключевые выводы

1. **BIP-39**: 12/24 слова → seed (PBKDF2) → один бэкап для всех ключей
2. **BIP-32**: иерархическая деривация — normal (xpub) и hardened (xprv)
3. **BIP-44**: `m/purpose'/coin'/account'/change/index` — стандарт путей
4. **Gap limit = 20**: алгоритм обнаружения адресов при восстановлении
5. **xpub** раскрывает все адреса, но не может тратить средства

## Что дальше?

В следующем уроке мы перейдём к практике — **программирование Bitcoin**: создание транзакций, работа с Bitcoin Core RPC и python-bitcoinlib.
