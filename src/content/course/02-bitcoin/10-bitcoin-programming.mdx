---
title: "Программирование Bitcoin"
description: "Практическая работа с Bitcoin — создание транзакций, RPC, python-bitcoinlib"
order: 10
difficulty: "advanced"
estimatedTime: 50
topics: ["Bitcoin RPC", "python-bitcoinlib", "Transaction Building", "Regtest", "PSBT"]
---

import { TransactionBuilderDiagram, PSBTDiagram, BitcoinRPCDiagram } from '../../../components/diagrams/module2';

# Программирование Bitcoin

## Настройка среды

```python
# Docker-based Bitcoin Core (regtest)
# docker-compose.yml в labs/bitcoin/

"""
services:
  bitcoind:
    image: bitcoin/bitcoin:27
    command:
      - -regtest
      - -rpcuser=student
      - -rpcpassword=password123
      - -rpcallowip=0.0.0.0/0
      - -rpcbind=0.0.0.0
      - -fallbackfee=0.0001
      - -txindex=1
    ports:
      - "18443:18443"  # RPC
      - "18444:18444"  # P2P
"""
```

## Bitcoin Core RPC

<BitcoinRPCDiagram client:load />

```python
import json
import urllib.request

class BitcoinRPC:
    """Клиент Bitcoin Core JSON-RPC"""

    def __init__(self, url="http://127.0.0.1:18443",
                 user="student", password="password123"):
        self.url = url
        self.auth = f"{user}:{password}"
        self._id = 0

    def call(self, method: str, params: list = None) -> dict:
        self._id += 1
        payload = {
            "jsonrpc": "2.0",
            "id": self._id,
            "method": method,
            "params": params or [],
        }

        data = json.dumps(payload).encode()
        import base64
        auth_header = base64.b64encode(self.auth.encode()).decode()

        req = urllib.request.Request(
            self.url,
            data=data,
            headers={
                "Content-Type": "application/json",
                "Authorization": f"Basic {auth_header}",
            },
        )

        with urllib.request.urlopen(req) as resp:
            result = json.loads(resp.read())

        if result.get("error"):
            raise Exception(f"RPC Error: {result['error']}")

        return result["result"]

    # Удобные методы
    def getblockchaininfo(self):
        return self.call("getblockchaininfo")

    def getnewaddress(self, label="", address_type="bech32"):
        return self.call("getnewaddress", [label, address_type])

    def generatetoaddress(self, nblocks: int, address: str):
        return self.call("generatetoaddress", [nblocks, address])

    def getbalance(self):
        return self.call("getbalance")

    def sendtoaddress(self, address: str, amount: float):
        return self.call("sendtoaddress", [address, amount])

    def getrawtransaction(self, txid: str, verbose: bool = True):
        return self.call("getrawtransaction", [txid, verbose])

    def decoderawtransaction(self, hex_tx: str):
        return self.call("decoderawtransaction", [hex_tx])

    def listunspent(self, min_conf=0, max_conf=9999999):
        return self.call("listunspent", [min_conf, max_conf])


# Пример использования (regtest)
"""
rpc = BitcoinRPC()

# Информация о сети
info = rpc.getblockchaininfo()
print(f"Chain: {info['chain']}")
print(f"Blocks: {info['blocks']}")

# Создаём адрес и майним 101 блок (для maturity)
addr = rpc.getnewaddress("miner", "bech32")
print(f"Address: {addr}")

rpc.generatetoaddress(101, addr)
balance = rpc.getbalance()
print(f"Balance: {balance} BTC")
"""
```

## Создание транзакций вручную

<TransactionBuilderDiagram client:load />

```python
import hashlib
import struct

class TransactionBuilder:
    """Построение Bitcoin транзакции с нуля"""

    def __init__(self, version: int = 2):
        self.version = version
        self.inputs = []
        self.outputs = []
        self.witnesses = []
        self.locktime = 0

    def add_input(self, txid: str, vout: int,
                  sequence: int = 0xFFFFFFFD):
        """Добавить вход (UTXO для траты)"""
        self.inputs.append({
            "txid": txid,
            "vout": vout,
            "script_sig": b"",  # Пустой для SegWit
            "sequence": sequence,
        })

    def add_output(self, amount_sat: int, script_pubkey: bytes):
        """Добавить выход"""
        self.outputs.append({
            "amount": amount_sat,
            "script_pubkey": script_pubkey,
        })

    def add_p2wpkh_output(self, amount_sat: int, pubkey_hash: bytes):
        """P2WPKH выход: OP_0 <20-byte hash>"""
        script = b'\x00\x14' + pubkey_hash
        self.add_output(amount_sat, script)

    def add_p2tr_output(self, amount_sat: int, output_key: bytes):
        """P2TR выход: OP_1 <32-byte key>"""
        script = b'\x51\x20' + output_key
        self.add_output(amount_sat, script)

    def add_op_return(self, data: bytes):
        """OP_RETURN (данные в блокчейне, non-spendable)"""
        assert len(data) <= 80, "OP_RETURN max 80 bytes"
        script = b'\x6a' + bytes([len(data)]) + data
        self.add_output(0, script)

    def serialize_unsigned(self) -> bytes:
        """Сериализация без witness (для txid)"""
        result = struct.pack('<I', self.version)

        # Inputs
        result += self._varint(len(self.inputs))
        for inp in self.inputs:
            result += bytes.fromhex(inp['txid'])[::-1]
            result += struct.pack('<I', inp['vout'])
            result += self._varint(len(inp['script_sig']))
            result += inp['script_sig']
            result += struct.pack('<I', inp['sequence'])

        # Outputs
        result += self._varint(len(self.outputs))
        for out in self.outputs:
            result += struct.pack('<q', out['amount'])
            result += self._varint(len(out['script_pubkey']))
            result += out['script_pubkey']

        result += struct.pack('<I', self.locktime)
        return result

    def serialize_witness(self) -> bytes:
        """Полная сериализация с witness"""
        result = struct.pack('<I', self.version)

        # SegWit marker + flag
        result += b'\x00\x01'

        # Inputs
        result += self._varint(len(self.inputs))
        for inp in self.inputs:
            result += bytes.fromhex(inp['txid'])[::-1]
            result += struct.pack('<I', inp['vout'])
            result += self._varint(len(inp['script_sig']))
            result += inp['script_sig']
            result += struct.pack('<I', inp['sequence'])

        # Outputs
        result += self._varint(len(self.outputs))
        for out in self.outputs:
            result += struct.pack('<q', out['amount'])
            result += self._varint(len(out['script_pubkey']))
            result += out['script_pubkey']

        # Witness
        for witness in self.witnesses:
            result += self._varint(len(witness))
            for item in witness:
                result += self._varint(len(item))
                result += item

        result += struct.pack('<I', self.locktime)
        return result

    def txid(self) -> str:
        """Transaction ID (double SHA-256 без witness)"""
        raw = self.serialize_unsigned()
        h = hashlib.sha256(hashlib.sha256(raw).digest()).digest()
        return h[::-1].hex()

    @staticmethod
    def _varint(n: int) -> bytes:
        if n < 0xfd:
            return bytes([n])
        elif n <= 0xffff:
            return b'\xfd' + struct.pack('<H', n)
        elif n <= 0xffffffff:
            return b'\xfe' + struct.pack('<I', n)
        else:
            return b'\xff' + struct.pack('<Q', n)


# Пример: построение транзакции
tx = TransactionBuilder(version=2)

# Вход: тратим UTXO
tx.add_input(
    txid="a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2",
    vout=0,
)

# Выходы
pubkey_hash = bytes(20)  # placeholder
tx.add_p2wpkh_output(amount_sat=90_000, pubkey_hash=pubkey_hash)
tx.add_p2wpkh_output(amount_sat=9_000, pubkey_hash=pubkey_hash)  # сдача
# Комиссия = input_amount - 90000 - 9000 = 1000 sat

raw = tx.serialize_unsigned()
print(f"Raw transaction: {raw.hex()[:80]}...")
print(f"Size: {len(raw)} bytes")
print(f"TXID: {tx.txid()}")
```

## PSBT — Partially Signed Bitcoin Transactions

<PSBTDiagram client:load />

```python
class PSBT:
    """
    BIP-174: Partially Signed Bitcoin Transaction

    PSBT позволяет разделить процесс создания транзакции:
    1. Creator — создаёт unsigned tx
    2. Updater — добавляет метаданные (UTXO info, scripts)
    3. Signer — добавляет подписи (может быть hardware wallet)
    4. Combiner — объединяет подписи от разных signers
    5. Finalizer — формирует финальный witness
    6. Extractor — извлекает готовую транзакцию

    Это критично для:
    - Hardware wallets (offline signing)
    - Multisig (несколько подписантов)
    - CoinJoin (несколько участников)
    """

    # PSBT magic bytes
    MAGIC = b'psbt\xff'

    def __init__(self):
        self.global_map = {}   # unsigned tx, xpubs
        self.inputs = []       # per-input data
        self.outputs = []      # per-output data

    @staticmethod
    def key_types() -> dict:
        """Типы ключей в PSBT"""
        return {
            "global": {
                0x00: "Unsigned Transaction",
                0x01: "Extended Public Key (xpub)",
                0x04: "PSBT Version",
            },
            "per_input": {
                0x00: "Non-Witness UTXO (full prev tx)",
                0x01: "Witness UTXO (prev output)",
                0x02: "Partial Signature",
                0x03: "Sighash Type",
                0x04: "Redeem Script (P2SH)",
                0x05: "Witness Script (P2WSH)",
                0x06: "BIP-32 Derivation Path",
                0x07: "Final scriptSig",
                0x08: "Final scriptWitness",
            },
            "per_output": {
                0x00: "Redeem Script",
                0x01: "Witness Script",
                0x02: "BIP-32 Derivation Path",
            },
        }

    @staticmethod
    def workflow_example() -> dict:
        """Пример PSBT workflow для multisig"""
        return {
            "step_1_create": {
                "role": "Creator (coordinator)",
                "action": "Создаёт PSBT с unsigned tx",
                "sends_to": ["Signer A", "Signer B"],
            },
            "step_2_update": {
                "role": "Updater",
                "action": "Добавляет UTXO info и derivation paths",
            },
            "step_3_sign": {
                "role": "Signers (parallel)",
                "signer_a": "Подписывает на Ledger → PSBT с sig_A",
                "signer_b": "Подписывает на Trezor → PSBT с sig_B",
            },
            "step_4_combine": {
                "role": "Combiner",
                "action": "Объединяет PSBT_A + PSBT_B",
            },
            "step_5_finalize": {
                "role": "Finalizer",
                "action": "Создаёт финальный witness из подписей",
            },
            "step_6_broadcast": {
                "role": "Extractor",
                "action": "Извлекает готовую tx и отправляет в сеть",
            },
        }

# RPC команды для PSBT
psbt_rpc_commands = {
    "createpsbt": "Создать PSBT (inputs, outputs)",
    "walletcreatefundedpsbt": "Создать PSBT с автовыбором UTXO",
    "walletprocesspsbt": "Подписать PSBT (wallet signer)",
    "combinepsbt": "Объединить несколько PSBT",
    "finalizepsbt": "Финализировать PSBT",
    "decodepsbt": "Декодировать PSBT для инспекции",
    "analyzepsbt": "Анализ: что ещё нужно для завершения",
}

print("=== PSBT RPC Commands ===\n")
for cmd, desc in psbt_rpc_commands.items():
    print(f"  {cmd}: {desc}")
```

## Работа с python-bitcoinlib

```python
"""
pip install python-bitcoinlib

Библиотека для работы с Bitcoin на уровне протокола.
"""

# === Пример 1: Создание ключей и адресов ===

from_lib_example = '''
import bitcoin
from bitcoin.core import CMutableTransaction, CMutableTxIn, CMutableTxOut, COutPoint
from bitcoin.core.script import CScript, OP_0
from bitcoin.wallet import CBitcoinAddress, CBitcoinSecret
import bitcoin.rpc

# Выбираем сеть
bitcoin.SelectParams('regtest')

# Подключение к Bitcoin Core
proxy = bitcoin.rpc.Proxy(
    service_url="http://student:password123@127.0.0.1:18443"
)

# Генерация ключей
import os
secret_bytes = os.urandom(32)
secret_key = CBitcoinSecret.from_secret_bytes(secret_bytes)
print(f"Private Key (WIF): {secret_key}")
print(f"Public Key: {secret_key.pub.hex()}")

# P2WPKH адрес
import hashlib
pubkey_hash = hashlib.new(
    'ripemd160',
    hashlib.sha256(secret_key.pub).digest()
).digest()
# Native SegWit: witness version 0 + pubkey hash
witness_script = CScript([OP_0, pubkey_hash])
'''

print("=== python-bitcoinlib пример ===")
print(from_lib_example)

# === Пример 2: Создание и отправка транзакции ===
tx_example = '''
# Получаем UTXO
utxos = proxy.listunspent()
utxo = utxos[0]
print(f"Using UTXO: {utxo['outpoint'].hash.hex()}:{utxo['outpoint'].n}")
print(f"Amount: {utxo['amount']} BTC")

# Создаём транзакцию
txin = CMutableTxIn(utxo['outpoint'])

# Получатель
dest_address = CBitcoinAddress(proxy.getnewaddress())
amount_to_send = int(0.5 * 100_000_000)  # 0.5 BTC в satoshi
fee = 1000  # satoshi

txout_dest = CMutableTxOut(amount_to_send, dest_address.to_scriptPubKey())
txout_change = CMutableTxOut(
    utxo['amount'] - amount_to_send - fee,
    utxo['scriptPubKey']  # сдача на тот же адрес
)

tx = CMutableTransaction([txin], [txout_dest, txout_change])

# Подписываем (через RPC для простоты)
signed = proxy.signrawtransactionwithwallet(tx)
assert signed['complete']

# Отправляем
txid = proxy.sendrawtransaction(signed['tx'])
print(f"Sent! TXID: {txid.hex()}")

# Майним блок для подтверждения
proxy.generatetoaddress(1, proxy.getnewaddress())
'''

print("\n=== Создание транзакции ===")
print(tx_example)
```

## Расширенные примеры

```python
# === Пример 3: OP_RETURN — данные в блокчейне ===
op_return_example = '''
from bitcoin.core.script import CScript, OP_RETURN

message = "Hello from Bitcoin regtest!".encode()
op_return_script = CScript([OP_RETURN, message])

txout_data = CMutableTxOut(0, op_return_script)
# Добавляем в транзакцию (amount = 0, non-spendable)
'''

# === Пример 4: Multisig P2WSH ===
multisig_example = '''
from bitcoin.core.script import CScript, OP_2, OP_3, OP_CHECKMULTISIG

# 2-of-3 multisig
pubkeys = [pubkey_alice, pubkey_bob, pubkey_carol]
redeem_script = CScript([OP_2] + pubkeys + [OP_3, OP_CHECKMULTISIG])

# P2WSH: OP_0 <SHA256(redeem_script)>
import hashlib
script_hash = hashlib.sha256(redeem_script).digest()
witness_script = CScript([OP_0, script_hash])

# Для траты нужны 2 из 3 подписей + redeem_script в witness
'''

# === Пример 5: Timelock ===
timelock_example = '''
from bitcoin.core.script import (
    CScript, OP_CHECKLOCKTIMEVERIFY, OP_DROP, OP_CHECKSIG
)

# Средства заблокированы до блока 200
lock_height = 200
timelock_script = CScript([
    lock_height, OP_CHECKLOCKTIMEVERIFY, OP_DROP,
    pubkey, OP_CHECKSIG
])

# Транзакция должна иметь nLockTime >= 200
tx.nLockTime = lock_height
# И nSequence < 0xFFFFFFFF для каждого входа
'''

# === Пример 6: Watch-Only Wallet с xpub ===
watch_only_example = '''
# Импорт xpub для отслеживания баланса без private key
descriptor = "wpkh(xpub6D4BDPc...)/*"

# Bitcoin Core 24+: используем descriptors
proxy.call("importdescriptors", [{
    "desc": descriptor,
    "timestamp": "now",
    "range": [0, 100],
    "watchonly": True,
}])

# Теперь можем видеть баланс, но не можем тратить
balance = proxy.getbalance()
utxos = proxy.listunspent()
'''

print("=== Расширенные примеры ===")
for name, code in [
    ("OP_RETURN", op_return_example),
    ("Multisig P2WSH", multisig_example),
    ("Timelock", timelock_example),
    ("Watch-Only", watch_only_example),
]:
    print(f"\n--- {name} ---")
    print(code)
```

## Полезные RPC команды

```python
essential_rpc = {
    "Блокчейн": {
        "getblockchaininfo": "Информация о сети",
        "getblock <hash>": "Получить блок",
        "getblockheader <hash>": "Заголовок блока",
        "getbestblockhash": "Хеш последнего блока",
        "getchaintips": "Все вершины цепи (forks)",
    },
    "Транзакции": {
        "getrawtransaction <txid> true": "Декодированная транзакция",
        "sendrawtransaction <hex>": "Отправить raw транзакцию",
        "testmempoolaccept [<hex>]": "Проверить без отправки",
        "getmempoolinfo": "Статус mempool",
    },
    "Кошелёк": {
        "listunspent": "Список UTXO",
        "getbalance": "Баланс",
        "getnewaddress": "Новый адрес",
        "dumpprivkey <addr>": "Экспорт private key (legacy)",
        "listdescriptors": "Все дескрипторы кошелька",
    },
    "PSBT": {
        "walletcreatefundedpsbt": "Создать PSBT",
        "walletprocesspsbt": "Подписать PSBT",
        "finalizepsbt": "Финализировать",
        "analyzepsbt": "Анализ PSBT",
    },
    "Mining (regtest)": {
        "generatetoaddress <n> <addr>": "Намайнить n блоков",
        "getmininginfo": "Информация о майнинге",
    },
}

for category, commands in essential_rpc.items():
    print(f"\n=== {category} ===")
    for cmd, desc in commands.items():
        print(f"  {cmd}: {desc}")
```

## Ключевые выводы

1. **Bitcoin Core RPC** — JSON-RPC интерфейс для взаимодействия с нодой
2. **Regtest** — локальная тестовая сеть для разработки
3. **TransactionBuilder** — пошаговое построение raw транзакций
4. **PSBT (BIP-174)** — стандарт для offline signing и multisig
5. **python-bitcoinlib** — низкоуровневая работа с протоколом

## Что дальше?

Мы завершили модуль Bitcoin! В следующем модуле мы перейдём к **Ethereum** — программируемому блокчейну со смарт-контрактами, EVM и DeFi.
