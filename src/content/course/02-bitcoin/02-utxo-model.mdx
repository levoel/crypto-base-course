---
title: "UTXO модель"
description: "Unspent Transaction Output — модель учёта балансов в Bitcoin"
order: 2
difficulty: "intermediate"
estimatedTime: 30
topics: ["UTXO", "Bitcoin Transactions", "Coin Selection"]
---

import { UTXOModelDiagram, UTXOTransactionDiagram, CoinSelectionDiagram } from '../../../components/diagrams/module2';

# UTXO модель

## Что такое UTXO?

**UTXO** (Unspent Transaction Output) — это неизрасходованный выход транзакции. В Bitcoin нет «балансов» — есть только набор UTXO, которыми вы можете распоряжаться.

<UTXOModelDiagram client:load />

> **Аналогия:** UTXO — это как купюры в кошельке. У вас нет абстрактного «баланса 150 руб.» — есть конкретные купюры: 100 руб. + 50 руб.

## UTXO vs Account модель

| Характеристика | UTXO (Bitcoin) | Account (Ethereum) |
|----------------|----------------|-------------------|
| Баланс | Сумма всех UTXO | Число в хранилище |
| Параллельность | Высокая (разные UTXO) | Низкая (nonce) |
| Приватность | Лучше (новый адрес) | Хуже (один адрес) |
| Размер состояния | Растёт | Фиксирован |
| Smart Contracts | Ограничены | Полные |

## Жизненный цикл UTXO

<UTXOTransactionDiagram client:load />

```python
class UTXO:
    """Unspent Transaction Output"""

    def __init__(self, txid: str, index: int, value: int, script: bytes):
        self.txid = txid        # Хеш транзакции, создавшей этот выход
        self.index = index      # Индекс выхода в транзакции
        self.value = value      # Сумма в сатоши
        self.script = script    # Условие траты (scriptPubKey)
        self.spent = False      # Флаг использования

    @property
    def outpoint(self) -> str:
        """Уникальный идентификатор UTXO"""
        return f"{self.txid}:{self.index}"

    def __repr__(self):
        return f"UTXO({self.outpoint}, {self.value} sat)"


class UTXOSet:
    """Множество всех неизрасходованных выходов"""

    def __init__(self):
        self.utxos: dict[str, UTXO] = {}

    def add(self, utxo: UTXO):
        """Добавить новый UTXO (при создании транзакции)"""
        self.utxos[utxo.outpoint] = utxo

    def spend(self, outpoint: str) -> UTXO:
        """Потратить UTXO (при включении транзакции в блок)"""
        utxo = self.utxos.pop(outpoint)
        utxo.spent = True
        return utxo

    def get_balance(self, address: str) -> int:
        """Получить баланс адреса"""
        return sum(
            u.value for u in self.utxos.values()
            if self._belongs_to(u, address)
        )

    def get_utxos_for(self, address: str) -> list:
        """Получить все UTXO для адреса"""
        return [
            u for u in self.utxos.values()
            if self._belongs_to(u, address)
        ]

    def _belongs_to(self, utxo: UTXO, address: str) -> bool:
        """Проверить принадлежность UTXO адресу"""
        # Упрощённо — проверяем скрипт
        return True  # В реальности: decode scriptPubKey

    def __len__(self):
        return len(self.utxos)
```

## Анатомия транзакции

```python
def create_transaction(
    inputs: list[UTXO],
    outputs: list[dict],  # [{address: str, value: int}]
    fee_rate: int = 10    # sat/vByte
) -> dict:
    """
    Создание Bitcoin транзакции:
    1. Сумма входов >= Сумма выходов + комиссия
    2. Каждый вход ссылается на существующий UTXO
    3. Остаток возвращается на адрес сдачи
    """
    total_input = sum(u.value for u in inputs)
    total_output = sum(o['value'] for o in outputs)

    # Оценка размера транзакции
    estimated_size = 10 + len(inputs) * 148 + len(outputs) * 34
    fee = estimated_size * fee_rate

    # Проверка баланса
    if total_input < total_output + fee:
        raise ValueError(
            f"Insufficient funds: {total_input} < {total_output + fee}"
        )

    # Сдача
    change = total_input - total_output - fee

    tx = {
        "version": 2,
        "inputs": [
            {
                "txid": u.txid,
                "vout": u.index,
                "scriptSig": "",  # Будет заполнено при подписании
            }
            for u in inputs
        ],
        "outputs": [
            {"value": o["value"], "scriptPubKey": o["address"]}
            for o in outputs
        ],
        "locktime": 0
    }

    # Добавляем сдачу (если > dust threshold)
    if change > 546:  # Dust threshold
        tx["outputs"].append({
            "value": change,
            "scriptPubKey": "change_address"
        })

    return tx

# Пример
alice_utxos = [
    UTXO("abc...1", 0, 50_000, b""),  # 0.0005 BTC
    UTXO("def...2", 1, 100_000, b""),  # 0.001 BTC
]

tx = create_transaction(
    inputs=alice_utxos,
    outputs=[
        {"address": "bc1q_bob...", "value": 80_000},  # 0.0008 BTC to Bob
    ]
)

print(f"Input total: {sum(u.value for u in alice_utxos)} sat")
print(f"Output to Bob: 80,000 sat")
print(f"Change: {tx['outputs'][1]['value'] if len(tx['outputs']) > 1 else 0} sat")
```

## Coin Selection (Выбор монет)

<CoinSelectionDiagram client:load />

Алгоритм выбора UTXO для транзакции — важная оптимизация.

```python
def coin_select_largest_first(
    utxos: list[UTXO],
    target: int,
    fee_rate: int = 10
) -> list[UTXO]:
    """
    Стратегия: сначала самые крупные UTXO
    + Меньше входов = меньше комиссия
    - Может создавать крупную сдачу
    """
    sorted_utxos = sorted(utxos, key=lambda u: u.value, reverse=True)
    selected = []
    total = 0

    for utxo in sorted_utxos:
        selected.append(utxo)
        total += utxo.value

        # Оценка комиссии
        fee = (10 + len(selected) * 148 + 2 * 34) * fee_rate

        if total >= target + fee:
            return selected

    raise ValueError("Insufficient funds")


def coin_select_branch_and_bound(
    utxos: list[UTXO],
    target: int,
    fee_rate: int = 10
) -> list[UTXO]:
    """
    Стратегия: Branch and Bound (Bitcoin Core)
    Пытается найти точный набор UTXO без сдачи
    + Минимизирует UTXO set
    + Улучшает приватность (нет сдачи)
    """
    # Упрощённая версия
    from itertools import combinations

    best = None
    best_waste = float('inf')

    for r in range(1, len(utxos) + 1):
        for combo in combinations(utxos, r):
            total = sum(u.value for u in combo)
            fee = (10 + r * 148 + 34) * fee_rate  # 1 output, no change

            waste = total - target - fee

            # Ищем минимальный waste >= 0
            if 0 <= waste < best_waste:
                best = list(combo)
                best_waste = waste

                if waste == 0:
                    return best

    if best is not None:
        return best

    # Fallback to largest first
    return coin_select_largest_first(utxos, target, fee_rate)


# Пример
utxos = [
    UTXO("a", 0, 10_000, b""),
    UTXO("b", 0, 25_000, b""),
    UTXO("c", 0, 50_000, b""),
    UTXO("d", 0, 100_000, b""),
    UTXO("e", 0, 75_000, b""),
]

target = 70_000

selected = coin_select_branch_and_bound(utxos, target)
print(f"Selected UTXOs: {selected}")
print(f"Total: {sum(u.value for u in selected)} sat")
```

## Работа с UTXO через Bitcoin RPC

```python
# Получить UTXO набор
utxos = rpc.call("listunspent", [1, 9999999])
for utxo in utxos:
    print(f"  {utxo['txid']}:{utxo['vout']} = {utxo['amount']} BTC")

# Создать raw transaction
raw_tx = rpc.call("createrawtransaction", [
    [{"txid": utxos[0]["txid"], "vout": utxos[0]["vout"]}],
    {new_address: 0.1, change_address: 49.8999}
])

# Подписать
signed = rpc.call("signrawtransactionwithwallet", [raw_tx])
print(f"Complete: {signed['complete']}")

# Отправить
txid = rpc.call("sendrawtransaction", [signed["hex"]])
print(f"Txid: {txid}")
```

## UTXO Dust

**Dust** — это UTXO, которое стоит меньше, чем комиссия за его трату.

```python
def is_dust(value: int, fee_rate: int = 10) -> bool:
    """
    Проверка на dust:
    UTXO считается dust, если стоимость его траты
    превышает 1/3 его номинала
    """
    # Размер входа для P2WPKH: ~68 vBytes
    spending_cost = 68 * fee_rate
    return value < 3 * spending_cost

# При fee_rate = 10 sat/vByte:
# Dust threshold ≈ 68 * 10 * 3 = 2040 sat
print(f"Dust threshold: {68 * 10 * 3} sat ({68 * 10 * 3 / 100_000_000:.8f} BTC)")
```

## Ключевые выводы

1. **UTXO** — неизрасходованный выход транзакции, аналог купюры
2. **Баланс** = сумма всех UTXO, которыми вы владеете
3. **Транзакция** потребляет старые UTXO и создаёт новые
4. **Coin Selection** — оптимизация выбора входов
5. **Dust** — слишком мелкие UTXO, которые невыгодно тратить

## Что дальше?

В следующем уроке мы изучим **Bitcoin Script** — язык программирования транзакций Bitcoin.
