---
title: "Lightning Network"
description: "Протокол второго уровня для мгновенных и дешёвых платежей в Bitcoin"
order: 8
difficulty: "advanced"
estimatedTime: 45
topics: ["Lightning Network", "Payment Channels", "HTLC", "Routing", "Layer 2"]
---

import { PaymentChannelDiagram, HTLCDiagram, LightningRoutingDiagram, ChannelLifecycleDiagram } from '../../../components/diagrams/module2';

# Lightning Network

## Проблема масштабируемости Bitcoin

```python
bitcoin_limits = {
    "block_size": "~4 MB (weight)",
    "block_time": "~10 минут",
    "transactions_per_block": "~2500-4000",
    "tps": "~7 tx/s",
    "visa_tps": "~65,000 tx/s",
    "gap": "~9000x",
}

print("=== Bitcoin On-chain Limits ===")
for k, v in bitcoin_limits.items():
    print(f"  {k}: {v}")

# Решение: Layer 2 — перенести транзакции off-chain,
# используя Bitcoin как settlement layer
```

## Payment Channels

<PaymentChannelDiagram client:load />

```python
import hashlib
import time

class PaymentChannel:
    """
    Двусторонний платёжный канал.

    1. Открытие: funding transaction (on-chain)
    2. Обновления: commitment transactions (off-chain)
    3. Закрытие: settlement transaction (on-chain)
    """

    def __init__(self, alice_balance: int, bob_balance: int):
        self.capacity = alice_balance + bob_balance
        self.state_number = 0
        self.states = []

        # Начальное состояние
        self._add_state(alice_balance, bob_balance)

    def _add_state(self, alice: int, bob: int):
        assert alice + bob == self.capacity, "Balance mismatch"
        assert alice >= 0 and bob >= 0, "Negative balance"

        self.state_number += 1
        state = {
            "number": self.state_number,
            "alice": alice,
            "bob": bob,
            "timestamp": int(time.time()),
        }
        self.states.append(state)
        return state

    def pay(self, sender: str, amount: int) -> dict:
        """Off-chain платёж через обновление состояния"""
        current = self.states[-1]

        if sender == "alice":
            new_alice = current["alice"] - amount
            new_bob = current["bob"] + amount
        else:
            new_alice = current["alice"] + amount
            new_bob = current["bob"] - amount

        return self._add_state(new_alice, new_bob)

    def get_current_state(self) -> dict:
        return self.states[-1]

    def close(self) -> dict:
        """Cooperative close — обе стороны подписывают финальное состояние"""
        final = self.states[-1]
        return {
            "type": "cooperative_close",
            "final_alice": final["alice"],
            "final_bob": final["bob"],
            "total_updates": len(self.states),
            "on_chain_txs": 2,  # funding + settlement
        }


# Пример
channel = PaymentChannel(alice_balance=500_000, bob_balance=300_000)
print(f"Канал открыт: {channel.capacity} sat")

# Off-chain платежи (бесплатные и мгновенные!)
channel.pay("alice", 50_000)   # Alice → Bob: 50k sat
channel.pay("bob", 20_000)     # Bob → Alice: 20k sat
channel.pay("alice", 100_000)  # Alice → Bob: 100k sat
channel.pay("alice", 30_000)   # Alice → Bob: 30k sat

state = channel.get_current_state()
print(f"\nПосле {state['number']} обновлений:")
print(f"  Alice: {state['alice']} sat")
print(f"  Bob: {state['bob']} sat")

result = channel.close()
print(f"\nЗакрытие: {result['total_updates']} off-chain транзакций")
print(f"On-chain транзакций: {result['on_chain_txs']}")
```

## Commitment Transactions

<ChannelLifecycleDiagram client:load />

```python
class CommitmentTransaction:
    """
    Commitment Transaction — off-chain транзакция состояния канала.

    Каждая сторона хранит свою версию commitment tx.
    Версии асимметричны — это ключ к безопасности!
    """

    def __init__(self, channel_id: str, state_number: int):
        self.channel_id = channel_id
        self.state_number = state_number

    @staticmethod
    def create_pair(alice_balance: int, bob_balance: int,
                    state_number: int) -> dict:
        """
        Создаём пару commitment transactions:

        Alice's version:
          - Alice's output: to_self (with revocation + timelock)
          - Bob's output: to_remote (immediately spendable by Bob)

        Bob's version (зеркальная):
          - Bob's output: to_self (with revocation + timelock)
          - Alice's output: to_remote (immediately spendable by Alice)
        """
        return {
            "alice_holds": {
                "outputs": [
                    {
                        "name": "to_local (Alice)",
                        "amount": alice_balance,
                        "script": "OP_IF <revocation_key> OP_ELSE "
                                  "<to_self_delay> OP_CSV OP_DROP <alice_key> OP_ENDIF "
                                  "OP_CHECKSIG",
                        "note": "Alice ждёт CSV delay ИЛИ Bob использует revocation key",
                    },
                    {
                        "name": "to_remote (Bob)",
                        "amount": bob_balance,
                        "script": "<bob_key> OP_CHECKSIG",
                        "note": "Bob может забрать сразу",
                    },
                ],
            },
            "bob_holds": {
                "outputs": [
                    {
                        "name": "to_local (Bob)",
                        "amount": bob_balance,
                        "script": "OP_IF <revocation_key> OP_ELSE "
                                  "<to_self_delay> OP_CSV OP_DROP <bob_key> OP_ENDIF "
                                  "OP_CHECKSIG",
                        "note": "Bob ждёт CSV delay ИЛИ Alice использует revocation key",
                    },
                    {
                        "name": "to_remote (Alice)",
                        "amount": alice_balance,
                        "script": "<alice_key> OP_CHECKSIG",
                        "note": "Alice может забрать сразу",
                    },
                ],
            },
        }


class RevocationMechanism:
    """
    Механизм отзыва старых состояний.

    При каждом обновлении стороны обмениваются
    revocation keys от ПРЕДЫДУЩЕГО состояния.
    """

    def __init__(self):
        self.revoked_states = {}

    def revoke_state(self, state_number: int, revocation_secret: bytes):
        """
        Отзыв старого состояния:
        Если кто-то опубликует отозванное состояние,
        контрагент заберёт ВСЕ средства канала!
        """
        self.revoked_states[state_number] = {
            "secret": revocation_secret.hex(),
            "penalty": "Все средства канала уходят пострадавшей стороне",
        }

    def check_breach(self, published_state: int) -> dict:
        if published_state in self.revoked_states:
            return {
                "breach_detected": True,
                "remedy": "Broadcast justice transaction",
                "result": "Забрать все средства канала",
            }
        return {"breach_detected": False}


# Пример
pair = CommitmentTransaction.create_pair(500_000, 300_000, state_number=1)
print("=== Alice holds ===")
for out in pair["alice_holds"]["outputs"]:
    print(f"  {out['name']}: {out['amount']} sat")
    print(f"    {out['note']}")
```

## HTLC — Hash Time-Locked Contracts

<HTLCDiagram client:load />

```python
import hashlib
import os

class HTLC:
    """
    HTLC — атомарный платёж через промежуточные узлы.

    Два условия траты:
    1. Получатель знает preimage хеша (success path)
    2. Таймаут истёк (refund path)
    """

    def __init__(self, amount: int, payment_hash: bytes, timeout: int):
        self.amount = amount
        self.payment_hash = payment_hash
        self.timeout = timeout  # blocks

    def script(self) -> str:
        """
        HTLC Script:
        OP_IF
            OP_SHA256 <payment_hash> OP_EQUALVERIFY
            <receiver_key> OP_CHECKSIG
        OP_ELSE
            <timeout> OP_CHECKLOCKTIMEVERIFY OP_DROP
            <sender_key> OP_CHECKSIG
        OP_ENDIF
        """
        return (
            f"OP_IF\n"
            f"  OP_SHA256 {self.payment_hash.hex()[:16]}... OP_EQUALVERIFY\n"
            f"  <receiver_key> OP_CHECKSIG\n"
            f"OP_ELSE\n"
            f"  {self.timeout} OP_CLTV OP_DROP\n"
            f"  <sender_key> OP_CHECKSIG\n"
            f"OP_ENDIF"
        )

    def claim(self, preimage: bytes) -> bool:
        """Получатель предъявляет preimage"""
        computed_hash = hashlib.sha256(preimage).digest()
        return computed_hash == self.payment_hash

    def refund(self, current_block: int) -> bool:
        """Отправитель забирает средства после таймаута"""
        return current_block >= self.timeout


def multi_hop_payment(path: list, amount: int, fee_per_hop: int = 1000):
    """
    Маршрутизация платежа через несколько хопов.

    Alice → Bob → Carol → Dave

    Каждый хоп создаёт HTLC с одним и тем же payment_hash,
    но с убывающим таймаутом (onion routing).
    """
    # Dave генерирует preimage и отправляет payment_hash Alice
    preimage = os.urandom(32)
    payment_hash = hashlib.sha256(preimage).digest()

    htlcs = []
    base_timeout = 144 * 3  # 3 дня в блоках

    for i, (sender, receiver) in enumerate(zip(path[:-1], path[1:])):
        hop_amount = amount + fee_per_hop * (len(path) - 2 - i)
        timeout = base_timeout - i * 144  # убывающий таймаут

        htlc = {
            "hop": i + 1,
            "sender": sender,
            "receiver": receiver,
            "amount": hop_amount,
            "timeout": timeout,
            "payment_hash": payment_hash.hex()[:16] + "...",
        }
        htlcs.append(htlc)

    return {
        "path": " → ".join(path),
        "htlcs": htlcs,
        "preimage": preimage.hex()[:16] + "...",
        "settlement": "Dave раскрывает preimage → Carol → Bob → Alice",
    }


# Пример: многоходовый платёж
result = multi_hop_payment(
    path=["Alice", "Bob", "Carol", "Dave"],
    amount=100_000,
    fee_per_hop=1000,
)

print(f"Маршрут: {result['path']}\n")
for htlc in result["htlcs"]:
    print(f"Hop {htlc['hop']}: {htlc['sender']} → {htlc['receiver']}")
    print(f"  Amount: {htlc['amount']} sat, Timeout: {htlc['timeout']} blocks")
```

## Onion Routing

<LightningRoutingDiagram client:load />

```python
import os
import hashlib

class OnionPacket:
    """
    Sphinx-based onion routing в Lightning Network.

    Каждый промежуточный узел знает только:
    - Предыдущий узел
    - Следующий узел
    - Сумму для пересылки

    Никто не знает полный маршрут!
    """

    def __init__(self, hops: list):
        self.hops = hops
        self.session_key = os.urandom(32)

    def build(self) -> list:
        """
        Построение onion-пакета (упрощённо):

        1. Для каждого хопа генерируем shared secret (ECDH)
        2. Каждый слой шифруется ключом, известным только этому узлу
        3. Промежуточный узел снимает свой слой и пересылает дальше
        """
        layers = []
        for i, hop in enumerate(reversed(self.hops)):
            layer = {
                "hop": len(self.hops) - i,
                "node": hop["node"],
                "payload": {
                    "next_node": hop.get("next_node", "FINAL"),
                    "amount": hop["amount"],
                    "cltv_expiry": hop["cltv"],
                },
                "encryption": f"ChaCha20 with shared_secret_{len(self.hops) - i}",
            }
            layers.append(layer)

        return list(reversed(layers))

    @staticmethod
    def privacy_properties() -> dict:
        return {
            "sender_privacy": "Промежуточные узлы не знают отправителя",
            "receiver_privacy": "Промежуточные узлы не знают получателя",
            "amount_privacy": "Каждый хоп видит только свою сумму",
            "route_privacy": "Никто не знает длину маршрута",
            "payment_correlation": "payment_hash одинаков — PTLCs решат это",
        }


# Пример
packet = OnionPacket([
    {"node": "Bob", "next_node": "Carol", "amount": 102_000, "cltv": 432},
    {"node": "Carol", "next_node": "Dave", "amount": 101_000, "cltv": 288},
    {"node": "Dave", "next_node": None, "amount": 100_000, "cltv": 144},
])

layers = packet.build()
for layer in layers:
    print(f"Hop {layer['hop']} ({layer['node']}):")
    print(f"  Next: {layer['payload']['next_node']}")
    print(f"  Amount: {layer['payload']['amount']} sat")
```

## BOLT спецификации

```python
bolt_specs = {
    "BOLT 1": "Base Protocol — сообщения, handshake, feature bits",
    "BOLT 2": "Channel Management — open, close, update",
    "BOLT 3": "Transactions — commitment tx, HTLC tx форматы",
    "BOLT 4": "Onion Routing — Sphinx пакеты",
    "BOLT 5": "On-chain — обработка закрытий, breach",
    "BOLT 7": "Gossip Protocol — анонсы каналов и узлов",
    "BOLT 8": "Transport — Noise Protocol (encrypted P2P)",
    "BOLT 9": "Feature Flags — обязательные и опциональные",
    "BOLT 11": "Invoices — платёжные запросы (lnbc...)",
    "BOLT 12": "Offers — статические платёжные запросы",
}

print("=== Lightning BOLTs ===\n")
for bolt, desc in bolt_specs.items():
    print(f"{bolt}: {desc}")
```

## Invoice (BOLT-11)

```python
class LightningInvoice:
    """Разбор Lightning Invoice (BOLT-11)"""

    @staticmethod
    def decode_example() -> dict:
        """
        Пример: lnbc1500n1p...

        Формат: ln + <currency> + <amount> + 1 + <data> + <signature>
        """
        return {
            "prefix": "lnbc",          # ln + bc (bitcoin mainnet)
            "amount": "1500n",          # 1500 nano-BTC = 150 sat
            "timestamp": 1700000000,
            "fields": {
                "p": "payment_hash (SHA256)",
                "d": "description (UTF-8)",
                "n": "payee node ID (33 bytes)",
                "x": "expiry (seconds, default 3600)",
                "r": "routing hints (for private channels)",
                "c": "min_final_cltv_expiry",
                "s": "payment_secret (for MPP)",
                "9": "feature bits",
            },
            "signature": "65 bytes (recovery_id + 64-byte sig)",
        }

    @staticmethod
    def create_invoice(amount_sat: int, description: str,
                       expiry: int = 3600) -> dict:
        """Создание invoice (упрощённо)"""
        import os
        preimage = os.urandom(32)
        payment_hash = hashlib.sha256(preimage).digest()

        return {
            "payment_hash": payment_hash.hex(),
            "preimage": preimage.hex(),
            "amount_msat": amount_sat * 1000,
            "description": description,
            "expiry": expiry,
            "created_at": int(time.time()),
            "status": "unpaid",
        }


invoice = LightningInvoice.create_invoice(
    amount_sat=50_000,
    description="Кофе в Bitcoin Café"
)
print("=== Lightning Invoice ===")
for k, v in invoice.items():
    if k in ("payment_hash", "preimage"):
        print(f"  {k}: {v[:32]}...")
    else:
        print(f"  {k}: {v}")
```

## Ключевые выводы

1. **Payment channels** — off-chain обновления баланса, 2 on-chain tx
2. **Commitment transactions** — асимметричные + revocation для наказания
3. **HTLC** — атомарные платежи через цепочку каналов
4. **Onion routing** — приватная маршрутизация (Sphinx)
5. **BOLT** — 12 спецификаций протокола Lightning

## Что дальше?

В следующем уроке мы изучим **Bitcoin кошельки** — HD-деривацию ключей, BIP-32/39/44 и seed-фразы.
