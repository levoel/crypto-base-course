---
title: "Архитектура Bitcoin"
description: "Обзор протокола Bitcoin — P2P сеть, блоки, консенсус"
order: 1
difficulty: "intermediate"
estimatedTime: 30
topics: ["Bitcoin", "P2P Network", "Protocol Architecture"]
---

import { BitcoinArchitectureDiagram, BitcoinNetworkDiagram, BlockchainChainDiagram } from '../../../components/diagrams/module2';

# Архитектура Bitcoin

## Что такое Bitcoin?

**Bitcoin** — это:
1. **Протокол** — набор правил для P2P сети
2. **Блокчейн** — распределённый реестр транзакций
3. **Валюта (BTC)** — нативный цифровой актив
4. **Сеть** — тысячи узлов по всему миру

<BitcoinArchitectureDiagram client:load />

## Компоненты системы

### 1. P2P Сеть

Bitcoin работает без центрального сервера. Каждый узел (node) равноправен.

<BitcoinNetworkDiagram client:load />

```python
# Типы узлов
nodes = {
    "Full Node": {
        "description": "Хранит полный блокчейн, валидирует все транзакции",
        "storage": "~500 GB",
        "examples": ["Bitcoin Core"]
    },
    "Pruned Node": {
        "description": "Хранит только последние блоки",
        "storage": "~5-10 GB",
        "examples": ["Bitcoin Core (pruned mode)"]
    },
    "Mining Node": {
        "description": "Full Node + создание новых блоков",
        "storage": "~500 GB + ASIC",
        "examples": ["Antminer + Bitcoin Core"]
    },
    "SPV Client": {
        "description": "Только заголовки блоков",
        "storage": "~50 MB",
        "examples": ["Electrum", "BlueWallet"]
    },
}
```

### 2. Блокчейн

<BlockchainChainDiagram client:load />

Блокчейн — это **связный список блоков**, где каждый блок содержит хеш предыдущего.

```python
class BlockHeader:
    """Заголовок блока Bitcoin (80 байт)"""

    def __init__(self):
        self.version = 0          # 4 байта: версия протокола
        self.prev_block = b''     # 32 байта: хеш предыдущего блока
        self.merkle_root = b''    # 32 байта: корень дерева транзакций
        self.timestamp = 0        # 4 байта: время создания
        self.bits = 0             # 4 байта: целевая сложность
        self.nonce = 0            # 4 байта: значение для PoW

    def serialize(self) -> bytes:
        """Сериализация заголовка (80 байт)"""
        import struct
        return (
            struct.pack('<I', self.version) +
            self.prev_block +
            self.merkle_root +
            struct.pack('<I', self.timestamp) +
            struct.pack('<I', self.bits) +
            struct.pack('<I', self.nonce)
        )

    def hash(self) -> bytes:
        """Хеш блока = SHA256d(header)"""
        import hashlib
        data = self.serialize()
        return hashlib.sha256(hashlib.sha256(data).digest()).digest()
```

### 3. Транзакции

Транзакция — это перевод BTC от одного или нескольких входов к одному или нескольким выходам.

```python
class Transaction:
    """Структура транзакции Bitcoin"""

    def __init__(self):
        self.version = 1          # Версия транзакции
        self.inputs = []          # Список входов (UTXO, которые тратим)
        self.outputs = []         # Список выходов (новые UTXO)
        self.locktime = 0         # Время блокировки

class TxInput:
    """Вход транзакции"""

    def __init__(self):
        self.prev_txid = b''      # Хеш предыдущей транзакции
        self.prev_index = 0       # Индекс выхода в предыдущей транзакции
        self.script_sig = b''     # Скрипт разблокировки (подпись)
        self.sequence = 0xFFFFFFFF

class TxOutput:
    """Выход транзакции"""

    def __init__(self):
        self.value = 0            # Сумма в сатоши (1 BTC = 100,000,000 sat)
        self.script_pubkey = b''  # Скрипт блокировки (условие траты)
```

### 4. Консенсус (Proof of Work)

```python
def proof_of_work(header: BlockHeader, target: int) -> int:
    """
    Найти nonce, при котором hash(header) < target
    """
    import hashlib

    for nonce in range(2**32):
        header.nonce = nonce
        block_hash = header.hash()

        # Сравниваем хеш с целью (little-endian)
        hash_int = int.from_bytes(block_hash, 'little')

        if hash_int < target:
            return nonce

    raise Exception("Nonce not found in 2^32 iterations")

# Сложность (difficulty) корректируется каждые 2016 блоков
# Цель: один блок каждые ~10 минут
```

## Жизненный цикл транзакции

```python
# 1. Создание
alice_creates_tx = {
    "from": "Alice's UTXO (1 BTC)",
    "to": [
        {"Bob": "0.5 BTC"},
        {"Alice (change)": "0.4999 BTC"},
        # 0.0001 BTC = комиссия майнеру
    ]
}

# 2. Подпись
alice_signs_with_private_key = "ECDSA signature on secp256k1"

# 3. Трансляция в сеть
broadcast_to_peers = "INV message → TX message"

# 4. Попадание в mempool
mempool_stores = "Неподтверждённые транзакции, отсортированные по fee rate"

# 5. Включение в блок
miner_selects = "Транзакции с наибольшей комиссией"

# 6. Proof of Work
miner_finds_nonce = "SHA256d(header) < target"

# 7. Подтверждение
confirmations = "Каждый новый блок = +1 подтверждение"
```

## Подключение к Bitcoin regtest

```python
import subprocess
import json
import requests

class BitcoinRPC:
    """Клиент для Bitcoin Core RPC"""

    def __init__(self, url="http://localhost:18443", user="crypto", password="crypto123"):
        self.url = url
        self.auth = (user, password)
        self.id = 0

    def call(self, method: str, params: list = []) -> dict:
        self.id += 1
        response = requests.post(
            self.url,
            json={
                "jsonrpc": "2.0",
                "id": self.id,
                "method": method,
                "params": params
            },
            auth=self.auth
        )
        result = response.json()
        if result.get("error"):
            raise Exception(result["error"])
        return result["result"]

# Использование (с запущенным Docker контейнером)
rpc = BitcoinRPC()

# Информация о сети
info = rpc.call("getblockchaininfo")
print(f"Chain: {info['chain']}")
print(f"Blocks: {info['blocks']}")

# Создать кошелек
rpc.call("createwallet", ["testwallet"])

# Получить новый адрес
address = rpc.call("getnewaddress")
print(f"Address: {address}")

# Намайнить 101 блок (чтобы получить спендабельные монеты)
rpc.call("generatetoaddress", [101, address])

# Проверить баланс
balance = rpc.call("getbalance")
print(f"Balance: {balance} BTC")
```

## Ключевые параметры Bitcoin

| Параметр | Значение |
|----------|----------|
| Время блока | ~10 минут |
| Размер блока | 1 MB (4 MB weight) |
| Награда за блок | 3.125 BTC (после 4-го halving) |
| Halving | Каждые 210,000 блоков (~4 года) |
| Максимальная эмиссия | 21,000,000 BTC |
| Consensus | Proof of Work (SHA-256d) |
| Difficulty adjustment | Каждые 2016 блоков |

## Ключевые выводы

1. **Bitcoin** — P2P сеть без центрального сервера
2. **Блокчейн** — связный список блоков с хешами
3. **Транзакции** — UTXO модель (входы → выходы)
4. **PoW** — безопасность через вычислительную работу
5. **80 байт** — размер заголовка блока

## Что дальше?

В следующем уроке мы погрузимся в **UTXO модель** — уникальный подход Bitcoin к отслеживанию балансов.
