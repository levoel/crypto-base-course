---
title: "Структура блоков"
description: "Анатомия блока Bitcoin — заголовок, транзакции, Merkle root"
order: 4
difficulty: "intermediate"
estimatedTime: 25
topics: ["Block Structure", "Block Header", "Coinbase Transaction"]
---

import { BlockStructureDiagram, BlockHeaderDiagram, CoinbaseDiagram } from '../../../components/diagrams/module2';

# Структура блоков Bitcoin

## Анатомия блока

Каждый блок Bitcoin состоит из **заголовка** (80 байт) и **списка транзакций**.

<BlockStructureDiagram client:load />

## Заголовок блока (Block Header)

<BlockHeaderDiagram client:load />

```python
import struct
import hashlib
from datetime import datetime

class BlockHeader:
    """80-байтный заголовок блока Bitcoin"""

    HEADER_SIZE = 80

    def __init__(self, version, prev_hash, merkle_root, timestamp, bits, nonce):
        self.version = version           # 4 байта
        self.prev_hash = prev_hash       # 32 байта (little-endian)
        self.merkle_root = merkle_root   # 32 байта
        self.timestamp = timestamp       # 4 байта (Unix timestamp)
        self.bits = bits                 # 4 байта (compact difficulty)
        self.nonce = nonce               # 4 байта

    def serialize(self) -> bytes:
        return (
            struct.pack('<I', self.version) +
            bytes.fromhex(self.prev_hash)[::-1] +  # Internal byte order
            bytes.fromhex(self.merkle_root)[::-1] +
            struct.pack('<I', self.timestamp) +
            struct.pack('<I', self.bits) +
            struct.pack('<I', self.nonce)
        )

    def block_hash(self) -> str:
        """Double SHA-256 хеш заголовка"""
        data = self.serialize()
        hash1 = hashlib.sha256(data).digest()
        hash2 = hashlib.sha256(hash1).digest()
        return hash2[::-1].hex()  # Display as big-endian

# Генезис-блок Bitcoin (Block #0)
genesis = BlockHeader(
    version=1,
    prev_hash="0" * 64,
    merkle_root="4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b",
    timestamp=1231006505,  # 3 января 2009 18:15:05 UTC
    bits=0x1d00ffff,
    nonce=2083236893
)

print(f"Genesis block hash: {genesis.block_hash()}")
# 000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f

print(f"Timestamp: {datetime.fromtimestamp(1231006505)}")
```

## Поле Version

```python
# BIP 9: Version bits для soft fork сигнализации
# Биты 3-28 используются для сигнализации поддержки BIP

def decode_version(version: int) -> dict:
    """Декодировать поле version"""
    # Top 3 bits = 001 для BIP 9
    is_bip9 = (version >> 29) == 0b001

    signals = {}
    if is_bip9:
        for bit in range(29):
            if version & (1 << bit):
                signals[bit] = True

    return {
        "version": version,
        "hex": hex(version),
        "bip9": is_bip9,
        "signal_bits": signals
    }

# Пример
print(decode_version(0x20000000))  # BIP9, без сигналов
print(decode_version(0x20000002))  # BIP9, сигнал на бит 1
```

## Difficulty Target

```python
def bits_to_target(bits: int) -> int:
    """
    Конвертация compact bits в полный target.
    bits = exponent (1 byte) || coefficient (3 bytes)
    target = coefficient × 2^(8×(exponent-3))
    """
    exponent = bits >> 24
    coefficient = bits & 0x007fffff

    if exponent <= 3:
        target = coefficient >> (8 * (3 - exponent))
    else:
        target = coefficient << (8 * (exponent - 3))

    return target

def target_to_difficulty(target: int) -> float:
    """
    Вычислить difficulty:
    difficulty = max_target / current_target
    """
    max_target = bits_to_target(0x1d00ffff)  # Difficulty 1
    return max_target / target

# Генезис-блок
genesis_target = bits_to_target(0x1d00ffff)
print(f"Genesis target: {genesis_target:064x}")
print(f"Genesis difficulty: {target_to_difficulty(genesis_target):.2f}")

# Текущая сложность (примерно)
current_bits = 0x17034219
current_target = bits_to_target(current_bits)
print(f"Current difficulty: {target_to_difficulty(current_target):,.0f}")
```

## Coinbase транзакция

<CoinbaseDiagram client:load />

Первая транзакция в каждом блоке — **coinbase** (создание новых BTC).

```python
class CoinbaseTransaction:
    """Специальная транзакция создания монет"""

    def __init__(self, block_height: int, extra_nonce: bytes = b'',
                 message: str = ''):
        # Coinbase input
        self.inputs = [{
            "txid": "0" * 64,        # Нулевой хеш
            "vout": 0xffffffff,        # 0xFFFFFFFF
            "coinbase": self._build_coinbase_data(
                block_height, extra_nonce, message
            ),
        }]

        # Награда + комиссии
        self.block_reward = self._calculate_reward(block_height)

    def _build_coinbase_data(self, height, extra_nonce, message) -> bytes:
        """Данные coinbase (2-100 байт)"""
        # BIP 34: высота блока обязательна
        height_bytes = height.to_bytes(
            (height.bit_length() + 7) // 8, 'little'
        )
        data = bytes([len(height_bytes)]) + height_bytes
        data += extra_nonce
        data += message.encode()[:80]
        return data

    @staticmethod
    def _calculate_reward(height: int) -> int:
        """
        Награда за блок:
        - Начальная: 50 BTC
        - Halving каждые 210,000 блоков
        """
        halvings = height // 210_000
        if halvings >= 64:
            return 0
        return 50_00000000 >> halvings  # В сатоши

# Награда по эпохам
for epoch in range(10):
    height = epoch * 210_000
    reward = CoinbaseTransaction._calculate_reward(height)
    print(f"Block {height:>8}: {reward / 1e8:.8f} BTC")

# Block        0: 50.00000000 BTC
# Block   210000: 25.00000000 BTC
# Block   420000: 12.50000000 BTC
# Block   630000:  6.25000000 BTC
# Block   840000:  3.12500000 BTC  ← Текущая эпоха
# ...
```

### Сообщение Сатоши в генезис-блоке

```python
# Coinbase data генезис-блока содержит знаменитое сообщение:
genesis_coinbase = bytes.fromhex(
    "04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e"
    "63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f7574"
    "20666f722062616e6b73"
)

# Декодируем сообщение
message = genesis_coinbase[8:].decode('ascii', errors='ignore')
print(f"Satoshi's message: {message}")
# "The Times 03/Jan/2009 Chancellor on brink of second bailout for banks"
```

## Merkle Root

```python
def compute_merkle_root(tx_hashes: list[bytes]) -> bytes:
    """Вычислить Merkle root из хешей транзакций"""
    if len(tx_hashes) == 0:
        return b'\x00' * 32

    level = tx_hashes[:]

    while len(level) > 1:
        if len(level) % 2 == 1:
            level.append(level[-1])

        next_level = []
        for i in range(0, len(level), 2):
            combined = level[i] + level[i + 1]
            hash_result = hashlib.sha256(
                hashlib.sha256(combined).digest()
            ).digest()
            next_level.append(hash_result)

        level = next_level

    return level[0]
```

## Работа с блоками через RPC

```python
# Получить информацию о блоке
block_hash = rpc.call("getbestblockhash")
block = rpc.call("getblock", [block_hash, 2])  # verbose=2 для полных транзакций

print(f"Height: {block['height']}")
print(f"Hash: {block['hash']}")
print(f"Prev: {block['previousblockhash']}")
print(f"Merkle: {block['merkleroot']}")
print(f"Tx count: {len(block['tx'])}")
print(f"Size: {block['size']} bytes")
print(f"Weight: {block['weight']} WU")

# Coinbase транзакция
coinbase = block['tx'][0]
print(f"\nCoinbase txid: {coinbase['txid']}")
print(f"Coinbase value: {coinbase['vout'][0]['value']} BTC")
```

## Ключевые выводы

1. **Заголовок блока** — 80 байт: version, prev_hash, merkle_root, timestamp, bits, nonce
2. **Block hash** — двойной SHA-256 от заголовка
3. **Coinbase** — первая транзакция, создаёт новые BTC
4. **Halving** — награда уменьшается вдвое каждые 210,000 блоков
5. **Merkle root** — корень дерева всех транзакций блока

## Что дальше?

В следующем уроке мы изучим **Proof of Work и майнинг** — как создаются новые блоки и обеспечивается безопасность сети.
