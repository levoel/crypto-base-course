---
title: "Proof of Work и майнинг"
description: "Алгоритм консенсуса Bitcoin — Proof of Work, сложность, и майнинг"
order: 5
difficulty: "intermediate"
estimatedTime: 30
topics: ["Proof of Work", "Mining", "Difficulty", "Consensus"]
---

import { ProofOfWorkDiagram, DifficultyAdjustmentDiagram, MiningPoolDiagram } from '../../../components/diagrams/module2';

# Proof of Work и майнинг

## Что такое Proof of Work?

**Proof of Work (PoW)** — механизм консенсуса, требующий от майнеров выполнить вычислительную работу для создания нового блока.

<ProofOfWorkDiagram client:load />

**Задача майнера:** Найти значение **nonce**, при котором хеш заголовка блока меньше **target**:

```
SHA256(SHA256(block_header)) < target
```

```python
import hashlib
import struct
import time

def mine_block(header_bytes: bytes, target: int, max_nonce: int = 2**32) -> tuple:
    """
    Майнинг: перебор nonce до нахождения хеша < target
    """
    start_time = time.time()
    attempts = 0

    for nonce in range(max_nonce):
        # Заменяем nonce в заголовке (последние 4 байта)
        header_with_nonce = header_bytes[:-4] + struct.pack('<I', nonce)

        # Double SHA-256
        hash1 = hashlib.sha256(header_with_nonce).digest()
        hash2 = hashlib.sha256(hash1).digest()

        # Сравниваем с target (little-endian)
        hash_int = int.from_bytes(hash2, 'little')
        attempts += 1

        if hash_int < target:
            elapsed = time.time() - start_time
            hashrate = attempts / elapsed if elapsed > 0 else 0

            return {
                "nonce": nonce,
                "hash": hash2[::-1].hex(),
                "attempts": attempts,
                "time": elapsed,
                "hashrate": hashrate,
            }

    raise Exception("Nonce not found")

# Демонстрация с низкой сложностью
import os

# Создаём фиктивный заголовок
header = os.urandom(76) + b'\x00\x00\x00\x00'

# Цель: хеш должен начинаться с 2 нулевых байт
target = 2**240  # Примерно difficulty 65536

result = mine_block(header, target)
print(f"Nonce: {result['nonce']}")
print(f"Hash: {result['hash']}")
print(f"Attempts: {result['attempts']}")
print(f"Time: {result['time']:.2f}s")
print(f"Hashrate: {result['hashrate']:.0f} H/s")
```

## Difficulty Adjustment

<DifficultyAdjustmentDiagram client:load />

Каждые **2016 блоков** (~2 недели) сложность пересчитывается:

```python
def calculate_new_target(
    old_target: int,
    actual_time: int,
    expected_time: int = 2016 * 600  # 2 недели в секундах
) -> int:
    """
    Корректировка сложности:
    new_target = old_target × (actual_time / expected_time)

    Ограничения: не более ×4 и не менее ÷4 за одну корректировку
    """
    # Ограничиваем коэффициент
    if actual_time < expected_time // 4:
        actual_time = expected_time // 4
    if actual_time > expected_time * 4:
        actual_time = expected_time * 4

    new_target = (old_target * actual_time) // expected_time

    # Не превышаем максимальный target
    max_target = 0x00000000FFFF0000000000000000000000000000000000000000000000000000
    if new_target > max_target:
        new_target = max_target

    return new_target

# Пример: блоки шли быстрее, чем ожидалось
actual = 2016 * 500  # 500 секунд вместо 600
expected = 2016 * 600

old_difficulty = 1_000_000
old_target = 2**256 // old_difficulty

new_target = calculate_new_target(old_target, actual)
new_difficulty = 2**256 // new_target

print(f"Old difficulty: {old_difficulty:,}")
print(f"New difficulty: {new_difficulty:,}")
print(f"Change: {(new_difficulty/old_difficulty - 1)*100:.1f}%")
```

## Эволюция майнинга

```python
hardware_evolution = [
    {"year": 2009, "type": "CPU", "hashrate": "10 MH/s", "efficiency": "~1000 J/GH"},
    {"year": 2010, "type": "GPU", "hashrate": "400 MH/s", "efficiency": "~10 J/GH"},
    {"year": 2011, "type": "FPGA", "hashrate": "1 GH/s", "efficiency": "~1 J/GH"},
    {"year": 2013, "type": "ASIC (28nm)", "hashrate": "10 TH/s", "efficiency": "~0.5 J/GH"},
    {"year": 2018, "type": "ASIC (7nm)", "hashrate": "50 TH/s", "efficiency": "~0.04 J/GH"},
    {"year": 2024, "type": "ASIC (3nm)", "hashrate": "200+ TH/s", "efficiency": "~0.02 J/GH"},
]

for hw in hardware_evolution:
    print(f"{hw['year']}: {hw['type']:15} | {hw['hashrate']:>12} | {hw['efficiency']}")
```

## Mining Pools

<MiningPoolDiagram client:load />

```python
class MiningPool:
    """Упрощённая модель пула майнинга"""

    def __init__(self, name: str):
        self.name = name
        self.miners = {}  # miner_id -> hashrate
        self.shares = {}  # miner_id -> share count

    def add_miner(self, miner_id: str, hashrate: float):
        self.miners[miner_id] = hashrate
        self.shares[miner_id] = 0

    def submit_share(self, miner_id: str, hash_value: int, share_target: int):
        """
        Майнер отправляет share (доказательство работы)
        Share target << block target (проще найти)
        """
        if hash_value < share_target:
            self.shares[miner_id] += 1
            return True
        return False

    def distribute_reward(self, block_reward: int, method: str = "PPLNS"):
        """
        Распределение награды:
        - PPS (Pay Per Share): фиксированная оплата за share
        - PPLNS (Pay Per Last N Shares): пропорционально последним shares
        - FPPS (Full Pay Per Share): PPS + комиссии
        """
        total_shares = sum(self.shares.values())
        if total_shares == 0:
            return {}

        rewards = {}
        for miner_id, shares in self.shares.items():
            proportion = shares / total_shares
            rewards[miner_id] = int(block_reward * proportion)

        return rewards

# Пример
pool = MiningPool("ExamplePool")
pool.add_miner("Alice", 100)  # 100 TH/s
pool.add_miner("Bob", 50)     # 50 TH/s

pool.shares = {"Alice": 200, "Bob": 100}

rewards = pool.distribute_reward(312_500_000)  # 3.125 BTC in satoshi
for miner, reward in rewards.items():
    print(f"{miner}: {reward / 1e8:.4f} BTC")
```

## Экономика майнинга

```python
def mining_profitability(
    hashrate_th: float,     # TH/s
    power_watts: float,     # W
    electricity_cost: float, # $/kWh
    btc_price: float,       # $/BTC
    network_hashrate_eh: float, # EH/s
    block_reward: float = 3.125, # BTC
) -> dict:
    """Расчёт прибыльности майнинга"""

    # Доля от сетевого хешрейта
    share = hashrate_th / (network_hashrate_eh * 1e6)  # EH -> TH

    # Ожидаемый доход в день
    blocks_per_day = 144
    daily_btc = share * blocks_per_day * block_reward
    daily_revenue = daily_btc * btc_price

    # Расходы на электричество
    daily_power_kwh = power_watts * 24 / 1000
    daily_electricity = daily_power_kwh * electricity_cost

    # Прибыль
    daily_profit = daily_revenue - daily_electricity

    return {
        "daily_btc": daily_btc,
        "daily_revenue": daily_revenue,
        "daily_electricity": daily_electricity,
        "daily_profit": daily_profit,
        "monthly_profit": daily_profit * 30,
        "breakeven_btc_price": daily_electricity / daily_btc if daily_btc > 0 else float('inf'),
    }

# Antminer S21 Pro
result = mining_profitability(
    hashrate_th=234,
    power_watts=3500,
    electricity_cost=0.05,
    btc_price=60000,
    network_hashrate_eh=600,
)

for key, value in result.items():
    print(f"{key}: ${value:.2f}" if 'profit' in key or 'revenue' in key or 'electricity' in key
          else f"{key}: {value:.6f}")
```

## Selfish Mining и атаки

```python
# 51% атака: контроль >50% хешрейта позволяет:
# 1. Double-spend — потратить BTC дважды
# 2. Цензура — блокировать определённые транзакции
# 3. Не позволяет: красть чужие BTC, изменять правила

def double_spend_probability(attacker_share: float, confirmations: int) -> float:
    """
    Вероятность успеха double-spend атаки:
    P(success) при q < 0.5 уменьшается экспоненциально с confirmations
    """
    q = attacker_share
    p = 1 - q

    if q >= 0.5:
        return 1.0

    # Формула из whitepaper Сатоши
    import math
    prob = 1.0
    lambda_param = confirmations * (q / p)

    sum_val = 1.0
    for k in range(confirmations):
        poisson = math.exp(-lambda_param) * lambda_param**k / math.factorial(k)
        prob -= poisson * (1 - (q/p)**(confirmations - k))

    return max(0, prob)

# Вероятность при разных confirmations
for confs in [1, 2, 3, 6, 12]:
    prob = double_spend_probability(0.3, confs)  # 30% атакующий
    print(f"{confs} confirmations: {prob*100:.4f}%")
```

## Ключевые выводы

1. **PoW** — поиск nonce для hash < target
2. **Difficulty** корректируется каждые 2016 блоков (цель: 10 мин/блок)
3. **ASIC** — специализированное оборудование для SHA-256d
4. **Pools** — объединение хешрейта для стабильного дохода
5. **6 confirmations** — стандарт безопасности для транзакций

## Что дальше?

В следующем уроке мы изучим **SegWit** — обновление, которое решило проблему malleability и увеличило эффективную ёмкость блоков.
