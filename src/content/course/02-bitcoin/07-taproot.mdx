---
title: "Taproot и Schnorr"
description: "Taproot upgrade — Schnorr подписи, MAST и key/script path spending в Bitcoin"
order: 7
difficulty: "advanced"
estimatedTime: 40
topics: ["Taproot", "Schnorr", "MAST", "BIP-340", "BIP-341", "BIP-342"]
---

import { TaprootStructureDiagram, MASTDiagram, KeyPathSpendDiagram, ScriptPathSpendDiagram } from '../../../components/diagrams/module2';

# Taproot и Schnorr

## Обзор Taproot

**Taproot** (активирован в ноябре 2021, блок 709,632) — крупнейшее обновление Bitcoin после SegWit, состоящее из трёх BIP:

```python
taproot_bips = {
    "BIP-340": {
        "title": "Schnorr Signatures for secp256k1",
        "description": "Новая схема подписей — линейная, позволяет агрегацию",
    },
    "BIP-341": {
        "title": "Taproot: SegWit version 1 spending rules",
        "description": "Новый тип выхода P2TR с key path и script path",
    },
    "BIP-342": {
        "title": "Tapscript",
        "description": "Обновлённые opcodes для Taproot скриптов",
    },
}

for bip, info in taproot_bips.items():
    print(f"{bip}: {info['title']}")
    print(f"  {info['description']}\n")
```

## Schnorr подписи (BIP-340)

<KeyPathSpendDiagram client:load />

```python
import hashlib
import secrets

# Параметры secp256k1
P = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F
N = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141
G_X = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798
G_Y = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8

def tagged_hash(tag: str, data: bytes) -> bytes:
    """BIP-340 tagged hash: SHA256(SHA256(tag) || SHA256(tag) || data)"""
    tag_hash = hashlib.sha256(tag.encode()).digest()
    return hashlib.sha256(tag_hash + tag_hash + data).digest()

class SchnorrSignature:
    """BIP-340 Schnorr подпись (x-only pubkeys)"""

    @staticmethod
    def sign(secret_key: bytes, message: bytes, aux_rand: bytes = None) -> bytes:
        """
        Schnorr Sign:
        1. d' = int(sk)
        2. P = d' × G, если y(P) нечётный: d = n - d', иначе d = d'
        3. t = xor(bytes(d), tagged_hash("BIP0340/aux", aux))
        4. k' = int(tagged_hash("BIP0340/nonce", t || bytes(P) || m)) mod n
        5. R = k' × G, если y(R) нечётный: k = n - k', иначе k = k'
        6. e = int(tagged_hash("BIP0340/challenge", bytes(R) || bytes(P) || m)) mod n
        7. sig = bytes(R) || bytes((k + e*d) mod n)
        """
        if aux_rand is None:
            aux_rand = secrets.token_bytes(32)

        d_prime = int.from_bytes(secret_key, 'big')
        assert 0 < d_prime < N

        # x-only: если y нечётный, отрицаем ключ
        # (упрощение — в реальности нужна ECC библиотека)
        d = d_prime  # предполагаем чётный y

        # Nonce generation
        t = bytes(a ^ b for a, b in zip(
            secret_key,
            tagged_hash("BIP0340/aux", aux_rand)
        ))

        # P как 32-байтовый x-only pubkey (заглушка)
        P_bytes = secret_key  # placeholder

        k_prime_bytes = tagged_hash("BIP0340/nonce", t + P_bytes + message)
        k_prime = int.from_bytes(k_prime_bytes, 'big') % N
        assert k_prime != 0

        k = k_prime  # предполагаем чётный y(R)

        # Challenge
        R_bytes = b'\x00' * 32  # placeholder для x(R)
        e = int.from_bytes(
            tagged_hash("BIP0340/challenge", R_bytes + P_bytes + message),
            'big'
        ) % N

        s = (k + e * d) % N
        return R_bytes + s.to_bytes(32, 'big')

    @staticmethod
    def verify(pubkey: bytes, message: bytes, signature: bytes) -> bool:
        """
        Schnorr Verify:
        1. P = lift_x(int(pubkey))
        2. r = int(sig[0:32]), s = int(sig[32:64])
        3. e = int(tagged_hash("BIP0340/challenge", sig[0:32] || pubkey || m)) mod n
        4. R = s × G - e × P
        5. Проверить: y(R) чётный И x(R) == r
        """
        assert len(pubkey) == 32, "x-only pubkey: 32 bytes"
        assert len(signature) == 64, "Schnorr sig: 64 bytes"

        r = int.from_bytes(signature[:32], 'big')
        s = int.from_bytes(signature[32:], 'big')

        e = int.from_bytes(
            tagged_hash("BIP0340/challenge", signature[:32] + pubkey + message),
            'big'
        ) % N

        # R = s × G - e × P (нужна ECC библиотека)
        # Проверка: x(R) == r и y(R) чётный
        return True  # placeholder

# Преимущества Schnorr над ECDSA:
advantages = [
    "64 байта (vs 71-72 для DER-encoded ECDSA)",
    "Линейность: позволяет агрегацию подписей (MuSig2)",
    "Batch verification: проверка N подписей быстрее чем N отдельных",
    "Provable security: доказуемая безопасность в random oracle model",
    "Нет malleability: каноническая форма подписи",
]

for i, adv in enumerate(advantages, 1):
    print(f"{i}. {adv}")
```

## Taproot Output (P2TR)

<TaprootStructureDiagram client:load />

```python
class TaprootOutput:
    """
    P2TR output — два пути траты:

    1. Key Path: одна подпись (выглядит как обычный платёж)
    2. Script Path: раскрытие скрипта из MAST дерева
    """

    def __init__(self, internal_key: bytes, scripts: list = None):
        """
        internal_key: 32-byte x-only pubkey
        scripts: список (script, leaf_version) для Merkle дерева
        """
        self.internal_key = internal_key
        self.scripts = scripts or []

    def compute_tweak(self) -> bytes:
        """
        tweak = tagged_hash("TapTweak", internal_key || merkle_root)

        Если нет скриптов: tweak = tagged_hash("TapTweak", internal_key)
        """
        if not self.scripts:
            return tagged_hash("TapTweak", self.internal_key)

        merkle_root = self._compute_merkle_root()
        return tagged_hash("TapTweak", self.internal_key + merkle_root)

    def output_key(self) -> bytes:
        """
        output_key = internal_key + tweak × G

        Это ключ, который попадает в scriptPubKey:
        OP_1 <32-byte output_key>
        """
        tweak = self.compute_tweak()
        # Q = P + t*G (нужна ECC библиотека)
        # Возвращаем placeholder
        return self.internal_key  # simplified

    def script_pubkey(self) -> bytes:
        """scriptPubKey для P2TR: OP_1 <32-byte-key>"""
        return b'\x51\x20' + self.output_key()

    def _compute_merkle_root(self) -> bytes:
        """MAST — Merkelized Abstract Syntax Tree"""
        if not self.scripts:
            return b''

        leaves = []
        for script, leaf_version in self.scripts:
            leaf_hash = tagged_hash(
                "TapLeaf",
                bytes([leaf_version]) +
                len(script).to_bytes(1, 'little') +
                script
            )
            leaves.append(leaf_hash)

        # Строим дерево Меркла
        while len(leaves) > 1:
            new_level = []
            for i in range(0, len(leaves), 2):
                if i + 1 < len(leaves):
                    # Сортируем для каноничности
                    left, right = sorted([leaves[i], leaves[i+1]])
                    branch = tagged_hash("TapBranch", left + right)
                    new_level.append(branch)
                else:
                    new_level.append(leaves[i])
            leaves = new_level

        return leaves[0]


# Пример: 2-of-3 multisig с Taproot
# Key Path: агрегированный ключ (MuSig2) — все 3 подписывают
# Script Path: любые 2 из 3

internal_key = bytes(32)  # MuSig2 aggregate key

scripts = [
    (b'\x20' + bytes(32) + b'\xac\x20' + bytes(32) + b'\xac\x9c', 0xc0),  # A+B
    (b'\x20' + bytes(32) + b'\xac\x20' + bytes(32) + b'\xac\x9c', 0xc0),  # A+C
    (b'\x20' + bytes(32) + b'\xac\x20' + bytes(32) + b'\xac\x9c', 0xc0),  # B+C
]

taproot = TaprootOutput(internal_key, scripts)
print(f"scriptPubKey: {taproot.script_pubkey().hex()}")
```

## MAST — Merkelized Abstract Syntax Tree

<MASTDiagram client:load />

```python
class MAST:
    """
    MAST позволяет скрыть неиспользованные условия траты.

    Вместо раскрытия ВСЕХ веток скрипта (как в P2SH),
    раскрывается только используемая ветка + Merkle proof.
    """

    @staticmethod
    def build_tree(scripts: list) -> dict:
        """
        Пример: контракт с 4 условиями траты

        - Условие A: Alice + Bob подписывают (обычный случай)
        - Условие B: Alice через 1 месяц (таймаут)
        - Условие C: Bob + Oracle (арбитраж)
        - Условие D: Alice + Bob + Charlie (экстренный случай)
        """
        leaf_hashes = []
        for i, script in enumerate(scripts):
            leaf = tagged_hash("TapLeaf", bytes([0xc0]) + script)
            leaf_hashes.append({
                "index": i,
                "script": script.hex(),
                "hash": leaf.hex()[:16] + "...",
            })

        return {
            "leaves": leaf_hashes,
            "privacy": "При key path трате — никто не знает о существовании скриптов",
            "efficiency": "При script path — раскрывается только 1 скрипт + proof",
        }

    @staticmethod
    def spending_comparison():
        """Сравнение P2SH vs Taproot для сложных скриптов"""
        return {
            "p2sh_multisig_3of5": {
                "reveal": "Все 5 pubkeys + скрипт + 3 подписи",
                "size": "~500 bytes",
                "privacy": "Видно: multisig 3-of-5",
            },
            "taproot_3of5": {
                "key_path": {
                    "reveal": "1 подпись (MuSig2)",
                    "size": "~64 bytes",
                    "privacy": "Выглядит как обычный платёж!",
                },
                "script_path": {
                    "reveal": "1 скрипт + Merkle proof + подписи",
                    "size": "~200 bytes",
                    "privacy": "Видна только используемая ветка",
                },
            },
        }

comparison = MAST.spending_comparison()
print("=== P2SH 3-of-5 ===")
for k, v in comparison["p2sh_multisig_3of5"].items():
    print(f"  {k}: {v}")

print("\n=== Taproot 3-of-5 (Key Path) ===")
for k, v in comparison["taproot_3of5"]["key_path"].items():
    print(f"  {k}: {v}")
```

## Script Path Spending

<ScriptPathSpendDiagram client:load />

```python
class ScriptPathSpend:
    """Трата через script path в Taproot"""

    @staticmethod
    def create_witness(script: bytes, control_block: bytes,
                       script_witness: list) -> list:
        """
        Witness для script path:
        [script_witness..., script, control_block]

        control_block = leaf_version | parity_bit || internal_key || merkle_path
        """
        witness = list(script_witness)
        witness.append(script)
        witness.append(control_block)
        return witness

    @staticmethod
    def build_control_block(internal_key: bytes, leaf_version: int,
                            parity: int, merkle_path: list) -> bytes:
        """
        Control Block:
        - Byte 0: (leaf_version & 0xfe) | parity_bit
        - Bytes 1-32: internal pubkey (x-only)
        - Bytes 33+: Merkle path (32 bytes per node)
        """
        header = (leaf_version & 0xfe) | (parity & 1)
        result = bytes([header]) + internal_key
        for node in merkle_path:
            result += node
        return result

# Пример: HTLC в Taproot
# Key Path: Alice + Bob соглашаются (cooperative close)
# Script Path A: Alice знает preimage
# Script Path B: Bob после таймаута

htlc_scripts = {
    "cooperative": "Key Path — одна подпись, минимальный размер",
    "alice_claims": "OP_SHA256 <hash> OP_EQUALVERIFY <alice_key> OP_CHECKSIG",
    "bob_timeout": "OP_CHECKLOCKTIMEVERIFY OP_DROP <bob_key> OP_CHECKSIG",
}

for path, desc in htlc_scripts.items():
    print(f"{path}: {desc}")
```

## Tapscript (BIP-342)

```python
tapscript_changes = {
    "OP_CHECKSIG": "Использует Schnorr вместо ECDSA",
    "OP_CHECKMULTISIG": "УДАЛЁН — заменён на OP_CHECKSIGADD",
    "OP_CHECKSIGADD": {
        "description": "Новый opcode для multisig",
        "mechanism": "Проверяет подпись и добавляет 1 к счётчику",
        "example": """
            <sig_A> <sig_B> <sig_C>
            <pubkey_A> OP_CHECKSIG
            <pubkey_B> OP_CHECKSIGADD
            <pubkey_C> OP_CHECKSIGADD
            3 OP_EQUAL
        """,
    },
    "OP_SUCCESS": {
        "description": "Зарезервированные opcodes для будущих soft forks",
        "range": "OP_SUCCESS80 - OP_SUCCESS254",
        "behavior": "Любой скрипт с OP_SUCCESS автоматически валиден",
    },
    "signature_validation": {
        "empty_sig": "Пустая подпись = неудача (не OP_0!)",
        "sighash": "Новые типы sighash: SIGHASH_DEFAULT (= ALL без байта)",
    },
}

print("=== Tapscript Changes (BIP-342) ===\n")
for op, change in tapscript_changes.items():
    if isinstance(change, str):
        print(f"{op}: {change}")
    else:
        print(f"\n{op}:")
        for k, v in change.items():
            print(f"  {k}: {v.strip() if isinstance(v, str) else v}")
```

## MuSig2: Агрегация ключей

```python
class MuSig2:
    """
    MuSig2 — протокол агрегации Schnorr подписей.

    Позволяет N участникам создать одну подпись,
    неотличимую от обычной Schnorr подписи.
    """

    @staticmethod
    def key_aggregation(pubkeys: list) -> dict:
        """
        Агрегация публичных ключей:
        1. L = H(P1 || P2 || ... || Pn) — key set hash
        2. ai = H(L || Pi) — коэффициент для каждого ключа
        3. P_agg = a1*P1 + a2*P2 + ... + an*Pn
        """
        # L = tagged_hash("KeyAgg list", concat(pubkeys))
        L = tagged_hash("KeyAgg list", b''.join(pubkeys))

        coefficients = []
        for pk in pubkeys:
            ai = tagged_hash("KeyAgg coefficient", L + pk)
            coefficients.append(ai)

        # P_agg = sum(ai * Pi) — нужна ECC
        return {
            "aggregate_key": "P_agg (32 bytes)",
            "coefficients": [c.hex()[:16] + "..." for c in coefficients],
            "property": "Выглядит как обычный x-only pubkey",
        }

    @staticmethod
    def signing_protocol() -> dict:
        """
        MuSig2 — 2 раунда подписи (vs 3 в MuSig1):

        Round 1: Каждый участник генерирует и отправляет nonce
        Round 2: Каждый вычисляет partial signature
        """
        return {
            "round_1": {
                "action": "Генерация nonce пар (Ri1, Ri2)",
                "communication": "Каждый отправляет свои nonce всем",
                "can_precompute": True,
            },
            "round_2": {
                "action": "Вычисление partial signature si",
                "aggregation": "s = s1 + s2 + ... + sn",
                "result": "Финальная подпись (R, s) — 64 байта",
            },
            "security": {
                "honest_majority": "Не требуется — безопасен при любом числе злоумышленников",
                "rogue_key_attack": "Защита через коэффициенты ai",
            },
        }

result = MuSig2.key_aggregation([bytes(32)] * 3)
print("Key Aggregation:", result)

protocol = MuSig2.signing_protocol()
for round_name, info in protocol.items():
    print(f"\n{round_name}:")
    for k, v in info.items():
        print(f"  {k}: {v}")
```

## Ключевые выводы

1. **Schnorr (BIP-340)** — 64-байтовые подписи с поддержкой агрегации
2. **P2TR** — два пути траты: key path (быстрый) и script path (гибкий)
3. **MAST** — скрывает неиспользованные ветки скрипта в Merkle дереве
4. **MuSig2** — N-of-N multisig выглядит как обычный платёж
5. **Tapscript** — обновлённый Script с OP_CHECKSIGADD

## Что дальше?

В следующем уроке мы изучим **Lightning Network** — протокол второго уровня, построенный поверх Bitcoin для мгновенных и дешёвых платежей.
